CCS PCH C Compiler, Version 4.068, 61971               13-May-15 12:44

               Filename: D:\Okul\PROJELER\çizgi izleyen\mert\Cisim Tamamlandý Teker Temizken Sol(Deðiþtirme)\mousesauro.lst

               ROM used: 6066 bytes (19%)
                         Largest free fragment is 20554
               RAM used: 1163 (57%) at main() level
                         1184 (58%) worst case
               Stack:    8 worst case (1 in main + 7 for interrupts)

*
1800:  GOTO   2624
*
1808:  MOVWF  05
180A:  MOVFF  FD8,06
180E:  MOVFF  FE0,07
1812:  MOVLB  0
1814:  MOVFF  FE9,0D
1818:  MOVFF  FEA,08
181C:  MOVFF  FE1,09
1820:  MOVFF  FE2,0A
1824:  MOVFF  FD9,0B
1828:  MOVFF  FDA,0C
182C:  MOVFF  FF3,14
1830:  MOVFF  FF4,15
1834:  MOVFF  FFA,16
1838:  MOVFF  00,0F
183C:  MOVFF  01,10
1840:  MOVFF  02,11
1844:  MOVFF  03,12
1848:  MOVFF  04,13
184C:  BTFSS  FA0.5
184E:  GOTO   1858
1852:  BTFSC  FA1.5
1854:  GOTO   2592
1858:  MOVFF  0F,00
185C:  MOVFF  10,01
1860:  MOVFF  11,02
1864:  MOVFF  12,03
1868:  MOVFF  13,04
186C:  BSF    0E.7
186E:  MOVFF  0D,FE9
1872:  MOVFF  08,FEA
1876:  MOVFF  09,FE1
187A:  MOVFF  0A,FE2
187E:  MOVFF  0B,FD9
1882:  MOVFF  0C,FDA
1886:  MOVFF  14,FF3
188A:  MOVFF  15,FF4
188E:  MOVFF  16,FFA
1892:  MOVF   05,W
1894:  MOVFF  07,FE0
1898:  MOVFF  06,FD8
189C:  RETFIE 0
.................... #include <mouse.h> 
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES HS                       //High speed Osc (> 4mhz for PCM/PCH) (>10mhz for PCD) 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES BROWNOUT                 //Reset when brownout detected 
.................... #FUSES BORV20                   //Brownout reset at 2.0V 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES STVREN                   //Stack full/underflow will cause reset 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES LVP                      //Low Voltage Programming on B3(PIC16) or B5(PIC18) 
.................... #FUSES NOWRT                    //Program memory not write protected 
.................... #FUSES NOWRTD                   //Data EEPROM not write protected 
.................... #FUSES IESO                     //Internal External Switch Over mode enabled 
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled 
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET 
.................... #FUSES NOWRTC                   //configuration not registers write protected 
.................... #FUSES NOWRTB                   //Boot block not write protected 
.................... #FUSES NOEBTR                   //Memory not protected from table reads 
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads 
.................... #FUSES NOCPB                    //No Boot Block code protection 
.................... #FUSES MCLR                     //Master Clear pin enabled 
.................... #FUSES NOLPT1OSC                  //Timer1 configured for low-power operation 
.................... #FUSES XINST                    //Extended set extension and Indexed Addressing mode enabled 
.................... #FUSES PLL5                     //Divide By 5(20MHz oscillator input) 
.................... #FUSES CPUDIV1                  //No System Clock Postscaler 
.................... #FUSES USBDIV                   //USB clock source comes from PLL divide by 2 
.................... #FUSES VREGEN                   //USB voltage regulator enabled 
....................  
.................... #use delay(clock=48000000) 
*
25FC:  CLRF   FEA
25FE:  MOVLW  8B
2600:  MOVWF  FE9
2602:  MOVF   FEF,W
2604:  BZ    2622
2606:  MOVLW  0F
2608:  MOVWF  01
260A:  CLRF   00
260C:  DECFSZ 00,F
260E:  BRA    260C
2610:  DECFSZ 01,F
2612:  BRA    260A
2614:  MOVLW  8F
2616:  MOVWF  00
2618:  DECFSZ 00,F
261A:  BRA    2618
261C:  NOP   
261E:  DECFSZ FEF,F
2620:  BRA    2606
2622:  RETLW  00
....................  
....................  
.................... #include <usb_bootloader.h> 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                     USB_BOOTLOADER.H                              //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example USB bootloader (ex_usb_bootloader                 //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  For more documentation see ex_usb_bootloader.c                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... //how big is the bootloader? 
.................... //the bootloader will reside from address 0x0000 to this location.  the 
.................... //application will then sit at this location+1 to the end of program memory. 
.................... #define LOADER_SIZE        (0x17FF) 
....................  
.................... //the loader and application need a common flag that determines if we are in 
.................... //the bootloader or application, that way the ISR knows where to go.  this 
.................... //is the location in ram that is reserved for this flag. 
.................... #define LOC_IN_LOADER_FLAG  0x25 
....................  
.................... //// --- end configuration --- //////////////////////////////////////////// 
....................  
.................... #reserve LOC_IN_LOADER_FLAG 
....................  
.................... int8 g_InBootloader; 
.................... #locate g_InBootloader=LOC_IN_LOADER_FLAG 
....................  
.................... #define LOADER_START       (0) 
.................... #define LOADER_END         (LOADER_SIZE) 
.................... #define APPLICATION_START  (LOADER_SIZE+1) 
.................... #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-1) 
.................... #define APPLICATION_ISR    (APPLICATION_START+8) 
....................  
.................... #ifdef _bootloader 
....................  /* 
....................   Provide an empty application, so if you load this .HEX file into the pic 
....................   without an application this will prevent the pic from executing unknown code. 
....................  */ 
....................  #org APPLICATION_START,APPLICATION_START+0xF 
....................  void BlankApplication(void)  
....................  { 
....................    while(TRUE); 
....................  } 
....................  
....................  //we need to prevent the loader from using application space 
....................  #if APPLICATION_END>0xFFFF 
....................    #org APPLICATION_START+0x10, 0xFFFF {} 
....................    #if APPLICATION_END>0x1FFFF 
....................       #org 0xFFFF, 0x1FFFF {} 
....................    #else 
....................       #org 0xFFFF, APPLICATION_END {} 
....................    #endif 
....................  #else 
....................    #org APPLICATION_START+0x10, APPLICATION_END {} 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef _bootloader 
....................  //in the application, this moves the reset and isr vector out of the bootload 
....................  //space.  it then reserves the loader space from being used by the application. 
....................  #build(reset=APPLICATION_START, interrupt=APPLICATION_ISR) 
....................  #org 0, LOADER_END {} 
.................... #endif 
....................  
.................... #include <usb_cdc.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                            usb_cdc.h                            //// 
.................... ////                                                                 //// 
.................... //// Library for adding a virtual COM port on your PC over USB using //// 
.................... //// the standard Communication Device Class (CDC) specification.    //// 
.................... //// Including this file in your code will add all USB code,         //// 
.................... //// interrupts, descriptors and handlers required.  No other        //// 
.................... //// modifications need to be made.                                  //// 
.................... ////                                                                 //// 
.................... //// This library creates a virtual RS232 link between the PC and    //// 
.................... //// the PIC, therefore the library provided will be familiar to     //// 
.................... //// anyone with standard UART stream I/O:                           //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_kbhit() - Returns TRUE if there is one or more          //// 
.................... ////      character received and waiting in the receive buffer.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_getc() - Gets a character from the receive buffer.  If  //// 
.................... ////      there is no data in the receive buffer it will wait until  //// 
.................... ////      there is data in the receive buffer.  If you do not want   //// 
.................... ////      to wait in an infinit loop, use usb_cdc_kbhit() first to   //// 
.................... ////      check if there is data before calling usb_cdc_getc().      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc(char c) - Puts a character into the transmit       //// 
.................... ////      buffer.  If the transmit buffer is full it will wait until //// 
.................... ////      the transmit buffer is not full before putting the char    //// 
.................... ////      into the transmit buffer.  The transmit buffer is read by  //// 
.................... ////      the PC very quickly, and therefore the buffer should only  //// 
.................... ////      be full for a few milli-seconds.  If you are concerned     //// 
.................... ////      and don't want to be stuck in a long or infinite loop,     //// 
.................... ////      use usb_cdc_putready() to see if there is space in the     //// 
.................... ////      transmit buffer before putting data into the transmit      //// 
.................... ////      buffer.                                                    //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putready() - Returns TRUE if there is room left in the  //// 
.................... ////      transmit buffer for another character.                     //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_connected() - Returns TRUE if we received a             //// 
.................... ////      Set_Line_Coding.  On most serial terminal programs (such   //// 
.................... ////      as Hyperterminal), they will send a Set_Line_Coding        //// 
.................... ////      message when the program starts and it opens the virtual   //// 
.................... ////      COM port.  This is a simple way to determine if the PC     //// 
.................... ////      is ready to display data on a serial terminal program,     //// 
.................... ////      but is not garaunteed to work all the time or on other     //// 
.................... ////      terminal programs.                                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_putc_fast(char c) - Similar to usb_cdc_putc(), except   //// 
.................... ////      if the transmit buffer is full it will skip the char.      //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_line_coding - A structure used for Set_Line_Coding and  //// 
.................... ////       Get_Line_Coding.  Most of the time you can ignore this.   //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_break - If the PC has sent a break command, this will   //// 
.................... ////       hold the break time (in milli-seconds).  If the PC sends  //// 
.................... ////       a value of 0xFFFF the device is supposed to hold the      //// 
.................... ////       break until it sends a value of 0                         //// 
.................... ////                                                                 //// 
.................... //// usb_cdc_carrier - Where Set_Control_Line_State value is stored. //// 
.................... ////       Of most relevance is the field dte_present, which is the  //// 
.................... ////       DTR setting.                                              //// 
.................... ////                                                                 //// 
.................... //// The following functions are also provided, and are ports of the //// 
.................... //// I/O functions in input.c.  See input.c and the CCS manual for   //// 
.................... //// documentation:                                                  //// 
.................... ////   get_float_usb() - Read a float number from the user           //// 
.................... ////   get_long_usb() - Read a long number from the user             //// 
.................... ////   get_int_usb() - Read an integer number from the user          //// 
.................... ////   get_string_usb(char *s, int max) - Read a string from the user. //// 
.................... ////   gethex_usb() - Read a byte, in HEX, from the user             //// 
.................... ////   gethex1_usb() - Read a HEX character                          //// 
.................... ////                                                                 //// 
.................... //// This driver will load all the rest of the USB code, and a set   //// 
.................... //// of descriptors that will properly describe a CDC device for a   //// 
.................... //// virtual COM port (usb_desc_cdc.h)                               //// 
.................... ////                                                                 //// 
.................... //// An .INF file is provided (cdc_NTXP.inf) that will load the      //// 
.................... //// standard CDC drivers for a virtual COM port in Windows          //// 
.................... //// NT/2000/XP and above.  Unfortunately we do not provide an .inf  //// 
.................... //// file for Windows 98 and ME.                                     //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// VERSION HISTORY                                                 //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2005: Changed the way incoming packets are        //// 
.................... ////               handled in that CDC driver will not flush         //// 
.................... ////               endpoint until user has handled all data.  This   //// 
.................... ////               will prevent overflows as the USB will NAK        //// 
.................... ////               incoming packets until it is ready to receive     //// 
.................... ////               more.                                             //// 
.................... ////            When using 18F4550 family, the RX buffer is          //// 
.................... ////               mapped directly to the endpoint buffer - this     //// 
.................... ////               saves a chunk of RAM.                             //// 
.................... ////            When using the 18F4550 family, you can increase      //// 
.................... ////               the TX and RX size over 64 bytes.                 //// 
.................... ////            No longer send 0len packets in the TBE interrupt.    //// 
.................... ////            Hopefully fixed bugs that caused random crashes      //// 
.................... ////               if you tried sending more than 64 bytes.          //// 
.................... ////                                                                 //// 
.................... //// July 6th, 2005: Global interrupts disabled when writing to TX   //// 
.................... ////                   buffer.                                       //// 
.................... ////                                                                 //// 
.................... //// July 1st, 2005: Initial Release.                                //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... //api for the user: 
.................... #define usb_cdc_kbhit() (usb_cdc_get_buffer_status.got) 
.................... #define usb_cdc_putready() (usb_cdc_put_buffer_nextin<USB_CDC_DATA_IN_SIZE) 
.................... #define usb_cdc_connected() (usb_cdc_got_set_line_coding) 
.................... void usb_cdc_putc_fast(char c); 
.................... char usb_cdc_getc(void); 
.................... void usb_cdc_putc(char c); 
....................  
.................... //input.c ported to use CDC: 
.................... float get_float_usb(); 
.................... signed long get_long_usb(); 
.................... signed int get_int_usb(); 
.................... void get_string_usb(char* s, int max); 
.................... BYTE gethex_usb(); 
.................... BYTE gethex1_usb(); 
....................  
.................... //functions automatically called by USB handler code 
.................... void usb_isr_tkn_cdc(void); 
.................... void usb_cdc_init(void); 
.................... void usb_isr_tok_out_cdc_control_dne(void); 
.................... void usb_isr_tok_in_cdc_data_dne(void); 
.................... void usb_isr_tok_out_cdc_data_dne(void); 
....................  
.................... void usb_cdc_flush_out_buffer(void); 
....................  
.................... //Tells the CCS PIC USB firmware to include HID handling code. 
.................... #DEFINE USB_HID_DEVICE  FALSE 
.................... #DEFINE USB_CDC_DEVICE  TRUE 
....................  
.................... #define USB_CDC_COMM_IN_ENDPOINT       1 
.................... #define USB_CDC_COMM_IN_SIZE           8 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT 
.................... #define USB_EP1_TX_SIZE  USB_CDC_COMM_IN_SIZE 
....................  
.................... //pic to pc endpoint config 
.................... #define USB_CDC_DATA_IN_ENDPOINT       2 
.................... #define USB_CDC_DATA_IN_SIZE           64 
.................... #define USB_EP2_TX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_TX_SIZE  USB_CDC_DATA_IN_SIZE 
....................  
.................... //pc to pic endpoint config 
.................... #define USB_CDC_DATA_OUT_ENDPOINT       2 
.................... #define USB_CDC_DATA_OUT_SIZE           64 
.................... #define USB_EP2_RX_ENABLE  USB_ENABLE_BULK 
.................... #define USB_EP2_RX_SIZE  USB_CDC_DATA_OUT_SIZE 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // Include the CCS USB Libraries.  See the comments at the top of these 
.................... // files for more information 
.................... // 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... #ifndef __USB_PIC_PERIF__ 
.................... #define __USB_PIC_PERIF__	1 
.................... #endif 
....................  
.................... #if __USB_PIC_PERIF__ 
....................  #if defined(__PCM__) 
....................   #error CDC requires bulk mode!  PIC16C7x5 does not have bulk mode 
....................  #else 
....................   #include <pic18_usb.h>   //Microchip 18Fxx5x hardware layer for usb.c 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes: //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor //// 
.................... ////   usb.c - USB token and request handler code                    //// 
.................... ////   usb.h - definitions, prototypes and global variables          //// 
.................... ////                                                                 //// 
.................... //// The following examples are provided by CCS:                     //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                 //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.       //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple  //// 
.................... ////                      interfaces.                                //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple //// 
.................... ////                      HID Reports.                               //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom        //// 
.................... ////                    protocol requiring custom Windows drivers.   //// 
.................... ////   ex_usb_serial.c -                                             //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for   //// 
.................... ////     a virtual COM port.                                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on C4 or C5 depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on C3, even if you are using  //// 
.................... ////  the internal 3.3V USB regulator.                               //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ////    ****************   USER FUNCTIONS  ***********************   //// 
.................... ////                                                                 //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and  //// 
.................... ////              attaches the unit to the usb bus.  Enables         //// 
.................... ////              interrupts.                                        //// 
.................... ////                                                                 //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit      //// 
.................... ////              to usb bus or enable interrupts.                   //// 
.................... ////                                                                 //// 
.................... //// usb_put_packet() - Sends one packet to the host.                //// 
.................... ////                    If you need to send a message that spans     //// 
.................... ////                    more than one packet then see usb_puts() in  //// 
.................... ////                    usb.c                                        //// 
.................... ////                                                                 //// 
.................... //// usb_kbhit() - Returns true if OUT endpoint contains data from   //// 
.................... ////               host.                                             //// 
.................... ////                                                                 //// 
.................... //// usb_rx_packet_size() - Returns the size of packet that was      //// 
.................... ////               received.  usb_kbhit() must return TRUE else      //// 
.................... ////               this is not valid.  Don't forget in USB there     //// 
.................... ////               are 0 len packets!                                //// 
.................... ////                                                                 //// 
.................... //// usb_get_packet() - Gets one packet that from the host.          //// 
.................... ////                    usb_kbhit() must return true before you call //// 
.................... ////                    this routine or your data may not be valid.  //// 
.................... ////                    Once usb_kbhit() returns true you want to    //// 
.................... ////                    call this as soon as possible to get data    //// 
.................... ////                    out of the endpoint buffer so the PC can     //// 
.................... ////                    start sending more data, if needed.          //// 
.................... ////                    This only receives one packet, if you are    //// 
.................... ////                    trying to receive a multi-packet message     //// 
.................... ////                    see usb_gets() in usb.c.                     //// 
.................... ////                                                                 //// 
.................... //// usb_detach() - De-attach USB from the system.                   //// 
.................... ////                                                                 //// 
.................... //// usb_attach() - Attach USB to the system.                        //// 
.................... ////                                                                 //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a    //// 
.................... ////                  USB cable.  A macro that looks at the defined  //// 
.................... ////                  connection sense pin.                          //// 
.................... ////                                                                 //// 
.................... //// usb_task() - Keeps track of connection sense, calling           //// 
.................... ////              usb_detach() and usb_attach() when needed.         //// 
.................... ////                                                                 //// 
.................... //// For more documentation on these functions read the comments at  //// 
.................... //// each function.                                                  //// 
.................... ////                                                                 //// 
.................... //// The other functions defined in this file are for use by the     //// 
.................... //// USB code, and is not meant to be used by the user.              //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_HARDWARE__ 
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_BUFFER_SPACE  ((int16)getenv("RAM")-0x500) 
....................  #define USB_MAX_NUM_ENDPOINTS  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #if (USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)>0 
....................    #error This driver only supports endpoints 0, 1 and 2 for this chip. 
....................  #endif 
....................  #define USB_MAX_NUM_ENDPOINTS  3 
....................  #define USB_TOTAL_BUFFER_SPACE  (0x100 - USB_MAX_NUM_ENDPOINTS*8) 
.................... #else 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_BUFFER_SPACE  ((int16)0x300) 
....................  #define USB_MAX_NUM_ENDPOINTS  16 
.................... #endif 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_CON_SENSE_PIN 
.................... #define USB_CON_SENSE_PIN  0 
.................... #endif 
....................  
.................... #if defined(__USB_4450__) 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define USB_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if (USB_BUFFER_NEEDED > USB_TOTAL_BUFFER_SPACE) 
....................  #error You are trying to allocate more memory for endpoints than the PIC can handle 
.................... #endif 
....................  
.................... #if defined(__USB_4450__) 
....................  #reserve 0x400:0x4FF 
.................... #else 
....................  #reserve 0x400:0x4FF+USB_BUFFER_NEEDED 
.................... #endif 
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
.................... //#define debug_usb printf 
.................... //#define debug_putc putc_tbe 
.................... #define debug_display_ram(x,y) 
.................... /* 
.................... void debug_display_ram(int8 len, int8 *ptr) { 
....................    int8 max=16; 
....................    debug_usb(debug_putc,"%U - ",len); 
....................    if (max>len) {max=len;} 
....................    while(max--) { 
....................       debug_usb(debug_putc,"%X",*ptr); 
....................       len--; 
....................       ptr++; 
....................    } 
....................    if (len) {debug_usb(debug_putc,"...");} 
.................... } 
.................... */ 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #ifndef USB_USE_ERROR_COUNTER 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #ifndef USB_PING_PONG_MODE 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte USTAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte USTAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... #byte UEP0    =  UEP0_LOC 
....................  
.................... #if defined(__USB_4450__) 
....................  #define USB_BUFFER (0x400 + (USB_MAX_NUM_ENDPOINTS*8)) 
....................  //#define USB_BUFFER 0x418   //if you have an old compiler you will need to use this 
.................... #else 
....................  #define USB_BUFFER 0x500 
.................... #endif 
....................  
.................... #byte BD0STAT  =  0x400 
.................... #byte BD0CNT  =  0x401 
.................... #byte BD0ADRL  =  0x402 
.................... #byte BD0ADRJ  =  0x403 
....................  
.................... #define BD0STAT_LOC 0x400 
.................... #define BD0CNT_LOC  0x401 
.................... #define BD0ADRL_LOC 0x402 
.................... #define BD0ADRH_LOC 0x403 
....................  
.................... #define UEP(x) *(UEP0_LOC+x) 
....................  
.................... #BIT UIR_SOF = UIR.6 
.................... #BIT UIR_STALL = UIR.5 
.................... #BIT UIR_IDLE = UIR.4 
.................... #BIT UIR_TRN = UIR.3 
.................... #BIT UIR_ACTV = UIR.2 
.................... #BIT UIR_UERR = UIR.1 
.................... #BIT UIR_URST = UIR.0 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    *(BD0STAT_LOC + x*8) 
....................  #define EP_BDxCNT_O(x)    *(BD0CNT_LOC + x*8) 
....................  #define EP_BDxADR_O(x)   *(int16 *)(BD0ADRL_LOC + x*8) 
....................  #define EP_BDxST_I(x)    *(BD0STAT_LOC + 4 + x*8) 
....................  #define EP_BDxCNT_I(x)    *(BD0CNT_LOC + 4 + x*8) 
....................  #define EP_BDxADR_I(x)   *(int16 *)(BD0ADRL_LOC + 4 + x*8) 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS 0x3F 
.................... #else 
....................  #define STANDARD_INTS 0x3D 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #define __USB_UCFG_UTRDIS  0x08 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #define __UCFG_VAL_DISABLED__ 0x08 
....................  
.................... char usb_ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_ep0_rx_buffer=USB_BUFFER 
....................  
.................... char usb_ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_ep0_tx_buffer=USB_BUFFER+USB_MAX_EP0_PACKET_LENGTH 
....................  
.................... char usb_data_buffer[USB_TOTAL_BUFFER_SPACE-USB_MAX_EP0_PACKET_LENGTH-USB_MAX_EP0_PACKET_LENGTH]; 
.................... #locate usb_data_buffer=USB_BUFFER+USB_MAX_EP0_PACKET_LENGTH+USB_MAX_EP0_PACKET_LENGTH 
....................  
.................... int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... //following functions standard part of CCS PIC USB driver, and used by usb.c 
.................... void usb_init(); 
.................... void usb_detach(); 
.................... int1 usb_put_packet(int endpoint, int * ptr, int16 len, USB_DTS_BIT tgl); 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); //marks the transmit buffer as ready for transmission 
.................... int16 usb_get_packet(int8 endpoint, int8 * ptr, int16 max); 
.................... int16 usb_rx_packet_size(int8 endpoint); 
.................... int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max); 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
.................... void usb_stall_ep(int8 endpoint); 
.................... void usb_unstall_ep(int8 endpoint); 
.................... int1 usb_endpoint_stalled(int8 endpoint); 
.................... void usb_set_address(int8 address); 
.................... void usb_set_configured(int config); 
.................... void usb_disable_endpoints(void); 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if USB_CON_SENSE_PIN 
....................  #define usb_attached() input(USB_CON_SENSE_PIN) 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void) {  //done 
....................    UCON=0;  //disable USB hardware 
....................    UIE=0;   //disable USB interrupts 
....................    UCFG = __UCFG_VAL_DISABLED__; 
....................    set_tris_c(*0xF94 | 0x30); 
....................    usb_state=USB_STATE_DETACHED; 
....................    usb_token_reset();              //clear the chapter9 stack 
....................    __usb_kbhit_status=0; 
.................... } 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void) { 
....................    usb_token_reset(); 
....................     UCON = 0; 
....................    UCFG = __UCFG_VAL_ENABLED__; 
....................     UIE = 0;                                // Mask all USB interrupts 
....................     UCON_USBEN = 1;                     // Enable module & attach to bus 
....................     usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: Resets and initalizes USB peripheral.  Does not attach the peripheral 
.................... /*          to the USB bus.  See usb_attach() and usb_task() on how to 
.................... /*          attach to the USB bus. 
.................... /* 
.................... /*          You must call this before any other USB code. 
.................... /* 
.................... /*          NOTE: an alternative function, usb_init(), is provided that 
.................... /*                initializes the USB and then connects. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #define usb_init_cs usb_detach 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: Keeps an eye on the connection sense pin to determine if we are 
.................... /*          attached to a USB cable or not.  If we are attached to a USB cable, 
.................... /*          initialize the USB peripheral if needed.  If we are disconnected 
.................... /*          from the USB cable, disable the USB peripheral. 
.................... /* 
.................... /*          NOTE: If you are not using a connection sense pin, will automatically 
.................... /*                enable the USB peripheral. 
.................... /* 
.................... /*          NOTE: this enables interrupts once the USB peripheral is ready 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void) { 
....................    if (usb_attached()) { 
....................       if (UCON_USBEN==0) { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
....................       } 
....................    } 
....................    else { 
....................       if (UCON_USBEN==1)  { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) { 
....................       UIR=0; 
....................       UIE=0; 
....................       enable_interrupts(INT_USB); 
....................       enable_interrupts(GLOBAL); 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB interrupt 
....................       usb_state=USB_STATE_POWERED; 
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: Resets and initalizes USB hardware.  You must call this first before 
.................... /*          using code.  Will attach the USB periperhal to the USB bus. 
.................... /* 
.................... /*          NOTE: If you are using a connection sense pin, this will wait in 
.................... /*                an infinite loop until the device is connected to a USB cable. 
.................... /* 
.................... /*          NOTE: If you are not using a connection sense pin, this will wait 
.................... /*                in an infinte loop until the SE0 condition clears, which usually 
.................... /*                doesn't take long 
.................... /* 
.................... /*          NOTE: this enables interrupts. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void) { 
....................    usb_init_cs(); 
....................  
....................    do { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
.................... } 
....................  
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC) 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) { 
....................    int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    i=EP_BDxST_I(endpoint); 
*
2204:  MOVF   x99,W
2206:  MULLW  08
2208:  MOVF   FF3,W
220A:  ADDLW  04
220C:  MOVWF  01
220E:  MOVLW  04
2210:  MOVWF  03
2212:  BTFSC  FD8.0
2214:  INCF   03,F
2216:  MOVFF  01,FE9
221A:  MOVFF  03,FEA
221E:  MOVFF  FEF,9D
....................    if (!bit_test(i,7)) { 
2222:  BTFSC  x9D.7
2224:  BRA    22DC
....................  
....................       EP_BDxCNT_I(endpoint)=len; 
2226:  MOVF   x99,W
2228:  MULLW  08
222A:  MOVF   FF3,W
222C:  ADDLW  05
222E:  MOVWF  01
2230:  MOVLW  04
2232:  MOVWF  03
2234:  BTFSC  FD8.0
2236:  INCF   03,F
2238:  MOVFF  01,FE9
223C:  MOVFF  03,FEA
2240:  MOVFF  9A,FEF
....................  
....................      debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE) { 
2244:  MOVF   x9C,W
2246:  SUBLW  02
2248:  BNZ   2276
....................          i=EP_BDxST_I(endpoint); 
224A:  MOVF   x99,W
224C:  MULLW  08
224E:  MOVF   FF3,W
2250:  ADDLW  04
2252:  MOVWF  01
2254:  MOVLW  04
2256:  MOVWF  03
2258:  BTFSC  FD8.0
225A:  INCF   03,F
225C:  MOVFF  01,FE9
2260:  MOVFF  03,FEA
2264:  MOVFF  FEF,9D
....................          if (bit_test(i,6)) 
2268:  BTFSS  x9D.6
226A:  BRA    2270
....................             tgl=USB_DTS_DATA0;  //was DATA1, goto DATA0 
226C:  CLRF   x9C
....................          else 
226E:  BRA    2274
....................             tgl=USB_DTS_DATA1;  //was DATA0, goto DATA1 
2270:  MOVLW  01
2272:  MOVWF  x9C
....................       } 
....................       else if (tgl == USB_DTS_USERX) { 
2274:  BRA    229C
2276:  MOVF   x9C,W
2278:  SUBLW  04
227A:  BNZ   229C
....................          i=EP_BDxST_O(endpoint); 
227C:  MOVF   x99,W
227E:  MULLW  08
2280:  MOVFF  FF3,01
2284:  MOVLW  04
2286:  MOVFF  01,FE9
228A:  MOVWF  FEA
228C:  MOVFF  FEF,9D
....................          if (bit_test(i,6)) 
2290:  BTFSS  x9D.6
2292:  BRA    229A
....................             tgl=USB_DTS_DATA1; 
2294:  MOVLW  01
2296:  MOVWF  x9C
....................          else 
2298:  BRA    229C
....................             tgl=USB_DTS_DATA0; 
229A:  CLRF   x9C
....................       } 
....................       if (tgl == USB_DTS_DATA1) { 
229C:  DECFSZ x9C,W
229E:  BRA    22A6
....................          i=0xC8;  //DATA1, UOWN 
22A0:  MOVLW  C8
22A2:  MOVWF  x9D
....................       } 
....................       else if (tgl == USB_DTS_DATA0) { 
22A4:  BRA    22AE
22A6:  MOVF   x9C,F
22A8:  BNZ   22AE
....................          i=0x88; //DATA0, UOWN 
22AA:  MOVLW  88
22AC:  MOVWF  x9D
....................       } 
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
22AE:  BTFSC  x9B.0
22B0:  BSF    x9D.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
22B2:  BTFSC  x9B.1
22B4:  BSF    x9D.1
....................  
....................       debug_usb(debug_putc," %X",i); 
....................  
....................       EP_BDxST_I(endpoint)=i;//save changes 
22B6:  MOVF   x99,W
22B8:  MULLW  08
22BA:  MOVF   FF3,W
22BC:  ADDLW  04
22BE:  MOVWF  01
22C0:  MOVLW  04
22C2:  MOVWF  03
22C4:  BTFSC  FD8.0
22C6:  INCF   03,F
22C8:  MOVFF  01,FE9
22CC:  MOVFF  03,FEA
22D0:  MOVFF  9D,FEF
....................  
....................       return(1); 
22D4:  MOVLW  01
22D6:  MOVWF  01
22D8:  BRA    22E0
....................    } 
....................     else { 
22DA:  BRA    22DC
....................          debug_usb(debug_putc,"\r\nPUT ERR"); 
....................     } 
....................    return(0); 
22DC:  MOVLW  00
22DE:  MOVWF  01
.................... } 
22E0:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_put_packet(endpoint,*ptr,len,toggle) 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to 
.................... /*        ptr - points to data to send 
.................... /*        len - amount of data to send 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only reason it will 
.................... /*         return FALSE is if because the TX buffer is still full from the last time you 
.................... /*         tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a difference 
.................... /*          between a packet and a message.  If you wanted to send a 512 byte message you 
.................... /*          would accomplish this by sending 8 64-byte packets, followed by a 0 length packet. 
.................... /*          If the last (or only packet) being sent is less than the max packet size defined 
.................... /*          in your descriptor then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message correctly. 
.................... /* 
.................... /********************************************************************************/ 
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl) { //done 
....................    int16 j; 
....................    int8 i; 
....................    int8 * buff_add;     
....................  
....................    i=EP_BDxST_I(endpoint); 
*
23CE:  MOVF   x8E,W
23D0:  MULLW  08
23D2:  MOVF   FF3,W
23D4:  ADDLW  04
23D6:  MOVWF  01
23D8:  MOVLW  04
23DA:  MOVWF  03
23DC:  BTFSC  FD8.0
23DE:  INCF   03,F
23E0:  MOVFF  01,FE9
23E4:  MOVFF  03,FEA
23E8:  MOVFF  FEF,96
....................    if (!bit_test(i,7)) { 
23EC:  BTFSC  x96.7
23EE:  BRA    246E
....................  
....................       buff_add=EP_BDxADR_I(endpoint); 
23F0:  MOVF   x8E,W
23F2:  MULLW  08
23F4:  MOVF   FF3,W
23F6:  ADDLW  06
23F8:  MOVWF  01
23FA:  MOVLW  04
23FC:  MOVWF  03
23FE:  BTFSC  FD8.0
2400:  INCF   03,F
2402:  MOVFF  01,FE9
2406:  MOVFF  03,FEA
240A:  MOVFF  FEC,03
240E:  MOVF   FED,F
2410:  MOVFF  FEF,97
2414:  MOVFF  03,98
....................  
....................       for (j=0;j<len;j++) { 
2418:  CLRF   x95
241A:  CLRF   x94
241C:  MOVF   x95,W
241E:  SUBWF  x92,W
2420:  BNC   2456
2422:  BNZ   242A
2424:  MOVF   x91,W
2426:  SUBWF  x94,W
2428:  BC    2456
....................          *buff_add=*ptr; 
242A:  MOVFF  8F,FE9
242E:  MOVFF  90,FEA
2432:  MOVFF  FEF,9B
2436:  MOVFF  98,FEA
243A:  MOVFF  97,FE9
243E:  MOVFF  9B,FEF
....................          buff_add++; 
2442:  INCF   x97,F
2444:  BTFSC  FD8.2
2446:  INCF   x98,F
....................          ptr++; 
2448:  INCF   x8F,F
244A:  BTFSC  FD8.2
244C:  INCF   x90,F
....................       } 
244E:  INCF   x94,F
2450:  BTFSC  FD8.2
2452:  INCF   x95,F
2454:  BRA    241C
....................  
....................       return(usb_flush_in(endpoint, len, tgl)); 
2456:  MOVFF  8E,99
245A:  MOVFF  92,9B
245E:  MOVFF  91,9A
2462:  MOVFF  93,9C
2466:  RCALL  2204
2468:  MOVF   01,W
246A:  BRA    2472
....................     } 
....................     else { 
246C:  BRA    246E
....................         debug_usb(debug_putc,"\r\nPUT ERR"); 
....................     } 
....................     return(0); 
246E:  MOVLW  00
2470:  MOVWF  01
.................... } 
2472:  GOTO   2492 (RETURN)
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB.C 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC) 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) { 
....................    int8 i; 
....................    int16 len; 
....................  
....................      #if USB_IGNORE_RX_DTS 
....................       if (tgl == USB_DTS_STALL) { 
....................          debug_usb(debug_putc, '*'); 
....................          i=0x84; 
....................          EP_BDxST_I(endpoint)=0x84; 
....................          return; 
....................       } 
....................       else 
....................          i=0x80; 
....................      #else 
....................       i=EP_BDxST_O(endpoint); 
*
211E:  MOVF   x8D,W
2120:  MULLW  08
2122:  MOVFF  FF3,01
2126:  MOVLW  04
2128:  MOVFF  01,FE9
212C:  MOVWF  FEA
212E:  MOVFF  FEF,8F
....................       if (tgl == USB_DTS_TOGGLE) { 
2132:  MOVF   x8E,W
2134:  SUBLW  02
2136:  BNZ   2144
....................          if (bit_test(i,6)) 
2138:  BTFSS  x8F.6
213A:  BRA    2140
....................             tgl=USB_DTS_DATA0;  //was DATA1, goto DATA0 
213C:  CLRF   x8E
....................          else 
213E:  BRA    2144
....................             tgl=USB_DTS_DATA1;  //was DATA0, goto DATA1 
2140:  MOVLW  01
2142:  MOVWF  x8E
....................       } 
....................       if (tgl == USB_DTS_STALL) { 
2144:  MOVF   x8E,W
2146:  SUBLW  03
2148:  BNZ   216E
....................          i=0x84; 
214A:  MOVLW  84
214C:  MOVWF  x8F
....................          EP_BDxST_I(endpoint)=0x84; //stall both in and out endpoints 
214E:  MOVF   x8D,W
2150:  MULLW  08
2152:  MOVF   FF3,W
2154:  ADDLW  04
2156:  MOVWF  01
2158:  MOVLW  04
215A:  MOVWF  03
215C:  BTFSC  FD8.0
215E:  INCF   03,F
2160:  MOVFF  01,FE9
2164:  MOVFF  03,FEA
2168:  MOVLW  84
216A:  MOVWF  FEF
....................       } 
....................       else if (tgl == USB_DTS_DATA1) { 
216C:  BRA    2180
216E:  DECFSZ x8E,W
2170:  BRA    2178
....................          i=0xC8;  //DATA1, UOWN 
2172:  MOVLW  C8
2174:  MOVWF  x8F
....................       } 
....................       else if (tgl == USB_DTS_DATA0) { 
2176:  BRA    2180
2178:  MOVF   x8E,F
217A:  BNZ   2180
....................          i=0x88; //DATA0, UOWN 
217C:  MOVLW  88
217E:  MOVWF  x8F
....................       } 
....................      #endif 
....................  
....................    bit_clear(__usb_kbhit_status,endpoint); 
2180:  CLRF   03
2182:  MOVLW  01
2184:  MOVWF  02
2186:  MOVF   x8D,W
2188:  MOVWF  00
218A:  BZ    2196
218C:  BCF    FD8.0
218E:  RLCF   02,F
2190:  RLCF   03,F
2192:  DECFSZ 00,F
2194:  BRA    218C
2196:  MOVF   02,W
2198:  XORLW  FF
219A:  MOVWF  00
219C:  MOVLW  FF
219E:  XORWF  03,F
21A0:  MOVF   00,W
21A2:  ANDWF  1C,F
21A4:  MOVF   03,W
21A6:  ANDWF  1D,F
....................  
....................    len=usb_ep_rx_size[endpoint]; 
21A8:  BCF    FD8.0
21AA:  RLCF   x8D,W
21AC:  CLRF   03
21AE:  MOVFF  FF2,92
21B2:  BCF    FF2.7
21B4:  CALL   190E
21B8:  TBLRD*+
21BA:  MOVFF  FF5,03
21BE:  BTFSC  x92.7
21C0:  BSF    FF2.7
21C2:  MOVWF  x90
21C4:  MOVFF  03,91
....................    EP_BDxCNT_O(endpoint)=len; 
21C8:  MOVF   x8D,W
21CA:  MULLW  08
21CC:  MOVF   FF3,W
21CE:  ADDLW  01
21D0:  MOVWF  01
21D2:  MOVLW  04
21D4:  MOVWF  03
21D6:  BTFSC  FD8.0
21D8:  INCF   03,F
21DA:  MOVFF  01,FE9
21DE:  MOVFF  03,FEA
21E2:  MOVFF  90,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
21E6:  BTFSC  x91.0
21E8:  BSF    x8F.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
21EA:  BTFSC  x91.1
21EC:  BSF    x8F.1
....................  
....................  
....................    EP_BDxST_O(endpoint)=i; 
21EE:  MOVF   x8D,W
21F0:  MULLW  08
21F2:  MOVFF  FF3,01
21F6:  MOVLW  04
21F8:  MOVFF  01,FE9
21FC:  MOVWF  FEA
21FE:  MOVFF  8F,FEF
.................... } 
2202:  RETLW  00
....................  
.................... int16 usb_rx_packet_size(int8 endpoint) { 
....................    return(EP_BDxCNT_O(endpoint)); 
*
233E:  MOVF   x8E,W
2340:  MULLW  08
2342:  MOVF   FF3,W
2344:  ADDLW  01
2346:  MOVWF  01
2348:  MOVLW  04
234A:  MOVWF  03
234C:  BTFSC  FD8.0
234E:  INCF   03,F
2350:  MOVFF  01,FE9
2354:  MOVFF  03,FEA
2358:  CLRF   03
235A:  MOVFF  FEF,01
235E:  MOVFF  03,02
.................... } 
2362:  GOTO   2370 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /********************************************************************************/ 
.................... int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max) { 
....................    int8 * al; 
....................    int8 st; 
....................    int16 i; 
....................  
....................    al=EP_BDxADR_O(endpoint); 
....................    i=EP_BDxCNT_O(endpoint); 
....................    st=EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i<max) {max=i;} 
....................  
....................    i=0; 
....................  
....................    while (i<max) { 
....................        *ptr=*al; 
....................        ptr++; 
....................        al++; 
....................        i++; 
....................    } 
....................  
....................    return(max); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM. 
.................... /*          Until you call usb_get_packet() the data will sit in the endpoint 
.................... /*          buffer and the PC will get NAKs when it tries to write more data 
.................... /*          to the endpoint. 
.................... /* 
.................... /********************************************************************************/ 
.................... int16 usb_get_packet(int8 endpoint, int8 * ptr, int16 max) { 
....................  
....................    max=usb_get_packet_buffer(endpoint,ptr,max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /********************************************************************************/ 
.................... int8 usb_tbe(int8 endpoint) { 
....................    int8 st; 
....................    st=EP_BDxST_I(endpoint); 
....................    if (!bit_test(st,7)) 
....................       return(TRUE); 
....................    return(FALSE); 
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_stall_ep(endpoint,direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will send STALL packet 
.................... /*          if the host tries to access this endpoint's buffer. 
.................... /* 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_stall_ep(int8 endpoint) {  //done 
....................    int1 direction; 
....................    direction=bit_test(endpoint,7); 
*
1F54:  BCF    x8E.0
1F56:  BTFSC  x8D.7
1F58:  BSF    x8E.0
....................    endpoint&=0x7F; 
1F5A:  BCF    x8D.7
....................    if (direction) { 
1F5C:  BTFSS  x8E.0
1F5E:  BRA    1F80
....................       EP_BDxST_I(endpoint)=0x84; 
1F60:  MOVF   x8D,W
1F62:  MULLW  08
1F64:  MOVF   FF3,W
1F66:  ADDLW  04
1F68:  MOVWF  01
1F6A:  MOVLW  04
1F6C:  MOVWF  03
1F6E:  BTFSC  FD8.0
1F70:  INCF   03,F
1F72:  MOVFF  01,FE9
1F76:  MOVFF  03,FEA
1F7A:  MOVLW  84
1F7C:  MOVWF  FEF
....................    } 
....................    else { 
1F7E:  BRA    1F94
....................       EP_BDxST_O(endpoint)=0x84; 
1F80:  MOVF   x8D,W
1F82:  MULLW  08
1F84:  MOVFF  FF3,01
1F88:  MOVLW  04
1F8A:  MOVFF  01,FE9
1F8E:  MOVWF  FEA
1F90:  MOVLW  84
1F92:  MOVWF  FEF
....................    } 
.................... } 
1F94:  GOTO   201C (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /********************************************************************************/ 
.................... void usb_unstall_ep(int8 endpoint) {   //done 
....................    int1 direction; 
....................    direction=bit_test(endpoint,7); 
*
1F12:  BCF    x8E.0
1F14:  BTFSC  x8D.7
1F16:  BSF    x8E.0
....................    endpoint&=0x7F; 
1F18:  BCF    x8D.7
....................    if (direction) { 
1F1A:  BTFSS  x8E.0
1F1C:  BRA    1F3E
....................       #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint)=0x80; 
....................       #else 
....................       EP_BDxST_I(endpoint)=0x88; 
1F1E:  MOVF   x8D,W
1F20:  MULLW  08
1F22:  MOVF   FF3,W
1F24:  ADDLW  04
1F26:  MOVWF  01
1F28:  MOVLW  04
1F2A:  MOVWF  03
1F2C:  BTFSC  FD8.0
1F2E:  INCF   03,F
1F30:  MOVFF  01,FE9
1F34:  MOVFF  03,FEA
1F38:  MOVLW  88
1F3A:  MOVWF  FEF
....................       #endif 
....................    } 
....................    else { 
1F3C:  BRA    1F50
....................       EP_BDxST_O(endpoint)=0x00; 
1F3E:  MOVF   x8D,W
1F40:  MULLW  08
1F42:  MOVFF  FF3,01
1F46:  MOVLW  04
1F48:  MOVFF  01,FE9
1F4C:  MOVWF  FEA
1F4E:  CLRF   FEF
....................    } 
.................... } 
1F50:  GOTO   2010 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_endpoint_stalled(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and Clear_Feature 
.................... /*          Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS 
.................... /********************************************************************************/ 
.................... int1 usb_endpoint_stalled(int8 endpoint) {   //done 
....................    int1 direction; 
....................    int8 st; 
....................    direction=bit_test(endpoint,7); 
*
1F98:  BCF    x8E.0
1F9A:  BTFSC  x8D.7
1F9C:  BSF    x8E.0
....................    endpoint&=0x7F; 
1F9E:  BCF    x8D.7
....................    if (direction) { 
1FA0:  BTFSS  x8E.0
1FA2:  BRA    1FC4
....................       st=EP_BDxST_I(endpoint); 
1FA4:  MOVF   x8D,W
1FA6:  MULLW  08
1FA8:  MOVF   FF3,W
1FAA:  ADDLW  04
1FAC:  MOVWF  01
1FAE:  MOVLW  04
1FB0:  MOVWF  03
1FB2:  BTFSC  FD8.0
1FB4:  INCF   03,F
1FB6:  MOVFF  01,FE9
1FBA:  MOVFF  03,FEA
1FBE:  MOVFF  FEF,8F
....................    } 
....................    else { 
1FC2:  BRA    1FD8
....................       st=EP_BDxST_O(endpoint); 
1FC4:  MOVF   x8D,W
1FC6:  MULLW  08
1FC8:  MOVFF  FF3,01
1FCC:  MOVLW  04
1FCE:  MOVFF  01,FE9
1FD2:  MOVWF  FEA
1FD4:  MOVFF  FEF,8F
....................    } 
....................    return(bit_test(st,7) && bit_test(st,2)); 
1FD8:  BTFSS  x8F.7
1FDA:  BRA    1FE0
1FDC:  BTFSC  x8F.2
1FDE:  BRA    1FE4
1FE0:  MOVLW  00
1FE2:  BRA    1FE6
1FE4:  MOVLW  01
1FE6:  MOVWF  01
.................... } 
1FE8:  GOTO   2030 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.  The host 
.................... /*          will now talk to use with the following address. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_set_address(int8 address) {   //done 
....................    UADDR=address; 
*
23AA:  MOVFF  8E,F6E
....................    if (address) { 
23AE:  MOVF   x8E,F
23B0:  BZ    23B8
....................       usb_state=USB_STATE_ADDRESS; 
23B2:  MOVLW  04
23B4:  MOVWF  1E
....................    } 
....................    else { 
23B6:  BRA    23BC
....................       usb_state=USB_STATE_POWERED; 
23B8:  MOVLW  02
23BA:  MOVWF  1E
....................    } 
.................... } 
23BC:  GOTO   23CA (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_set_configured(config) 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_set_configured(int config) { 
....................    int8 en; 
....................    int16 addy; 
....................    int8 new_uep; 
....................    int16 len; 
....................    int8 i; 
....................       if (config==0) { 
*
1BFA:  MOVF   x8D,F
1BFC:  BNZ   1C06
....................          //if config=0 then set addressed state 
....................          usb_state=USB_STATE_ADDRESS; 
1BFE:  MOVLW  04
1C00:  MOVWF  1E
....................          usb_disable_endpoints(); 
1C02:  RCALL  1A62
....................       } 
....................       else { 
1C04:  BRA    1D88
....................          usb_state=USB_STATE_CONFIGURED; //else set configed state 
1C06:  MOVLW  05
1C08:  MOVWF  1E
....................          addy=(int16)USB_BUFFER+(2*USB_MAX_EP0_PACKET_LENGTH); 
1C0A:  MOVWF  x90
1C0C:  MOVLW  80
1C0E:  MOVWF  x8F
....................          for (en=1;en<16;en++) { 
1C10:  MOVLW  01
1C12:  MOVWF  x8E
1C14:  MOVF   x8E,W
1C16:  SUBLW  0F
1C18:  BTFSS  FD8.0
1C1A:  BRA    1D88
....................             new_uep=0; 
1C1C:  CLRF   x91
....................             if (usb_ep_rx_type[en]!=USB_ENABLE_DISABLED) { 
1C1E:  CLRF   03
1C20:  MOVF   x8E,W
1C22:  MOVFF  FF2,95
1C26:  BCF    FF2.7
1C28:  RCALL  18BE
1C2A:  BTFSC  x95.7
1C2C:  BSF    FF2.7
1C2E:  XORLW  00
1C30:  BZ    1CD4
....................                new_uep=0x04; 
1C32:  MOVLW  04
1C34:  MOVWF  x91
....................                len=usb_ep_rx_size[en]; 
1C36:  BCF    FD8.0
1C38:  RLCF   x8E,W
1C3A:  CLRF   03
1C3C:  MOVFF  FF2,95
1C40:  BCF    FF2.7
1C42:  RCALL  190E
1C44:  TBLRD*+
1C46:  MOVFF  FF5,03
1C4A:  BTFSC  x95.7
1C4C:  BSF    FF2.7
1C4E:  MOVWF  x92
1C50:  MOVFF  03,93
....................                EP_BDxCNT_O(en)=len; 
1C54:  MOVF   x8E,W
1C56:  MULLW  08
1C58:  MOVF   FF3,W
1C5A:  ADDLW  01
1C5C:  MOVWF  01
1C5E:  MOVLW  04
1C60:  MOVWF  03
1C62:  BTFSC  FD8.0
1C64:  INCF   03,F
1C66:  MOVFF  01,FE9
1C6A:  MOVFF  03,FEA
1C6E:  MOVFF  92,FEF
....................                EP_BDxADR_O(en)=addy; 
1C72:  MOVF   x8E,W
1C74:  MULLW  08
1C76:  MOVF   FF3,W
1C78:  ADDLW  02
1C7A:  MOVWF  01
1C7C:  MOVLW  04
1C7E:  MOVWF  03
1C80:  BTFSC  FD8.0
1C82:  INCF   03,F
1C84:  MOVFF  01,FE9
1C88:  MOVFF  03,FEA
1C8C:  MOVFF  90,FEC
1C90:  MOVF   FED,F
1C92:  MOVFF  8F,FEF
....................                addy+=usb_ep_rx_size[en]; 
1C96:  BCF    FD8.0
1C98:  RLCF   x8E,W
1C9A:  CLRF   03
1C9C:  MOVFF  FF2,95
1CA0:  BCF    FF2.7
1CA2:  RCALL  190E
1CA4:  TBLRD*+
1CA6:  MOVFF  FF5,03
1CAA:  BTFSC  x95.7
1CAC:  BSF    FF2.7
1CAE:  ADDWF  x8F,F
1CB0:  MOVF   03,W
1CB2:  ADDWFC x90,F
....................                #if USB_IGNORE_RX_DTS 
....................                   i=0x80; 
....................                #else 
....................                   i=0x88; 
1CB4:  MOVLW  88
1CB6:  MOVWF  x94
....................                #endif 
....................                if (bit_test(len,8)) {bit_set(i,0);} 
1CB8:  BTFSC  x93.0
1CBA:  BSF    x94.0
....................                if (bit_test(len,9)) {bit_set(i,1);} 
1CBC:  BTFSC  x93.1
1CBE:  BSF    x94.1
....................                EP_BDxST_O(en)=i; 
1CC0:  MOVF   x8E,W
1CC2:  MULLW  08
1CC4:  MOVFF  FF3,01
1CC8:  MOVLW  04
1CCA:  MOVFF  01,FE9
1CCE:  MOVWF  FEA
1CD0:  MOVFF  94,FEF
....................             } 
....................             if (usb_ep_tx_type[en]!=USB_ENABLE_DISABLED) { 
1CD4:  CLRF   03
1CD6:  MOVF   x8E,W
1CD8:  MOVFF  FF2,95
1CDC:  BCF    FF2.7
1CDE:  RCALL  189E
1CE0:  BTFSC  x95.7
1CE2:  BSF    FF2.7
1CE4:  XORLW  00
1CE6:  BZ    1D4A
....................                new_uep|=0x02; 
1CE8:  BSF    x91.1
....................                EP_BDxADR_I(en)=addy; 
1CEA:  MOVF   x8E,W
1CEC:  MULLW  08
1CEE:  MOVF   FF3,W
1CF0:  ADDLW  06
1CF2:  MOVWF  01
1CF4:  MOVLW  04
1CF6:  MOVWF  03
1CF8:  BTFSC  FD8.0
1CFA:  INCF   03,F
1CFC:  MOVFF  01,FE9
1D00:  MOVFF  03,FEA
1D04:  MOVFF  90,FEC
1D08:  MOVF   FED,F
1D0A:  MOVFF  8F,FEF
....................                addy+=usb_ep_tx_size[en]; 
1D0E:  BCF    FD8.0
1D10:  RLCF   x8E,W
1D12:  CLRF   03
1D14:  MOVFF  FF2,95
1D18:  BCF    FF2.7
1D1A:  RCALL  18DE
1D1C:  TBLRD*+
1D1E:  MOVFF  FF5,03
1D22:  BTFSC  x95.7
1D24:  BSF    FF2.7
1D26:  ADDWF  x8F,F
1D28:  MOVF   03,W
1D2A:  ADDWFC x90,F
....................                EP_BDxST_I(en)=0x40; 
1D2C:  MOVF   x8E,W
1D2E:  MULLW  08
1D30:  MOVF   FF3,W
1D32:  ADDLW  04
1D34:  MOVWF  01
1D36:  MOVLW  04
1D38:  MOVWF  03
1D3A:  BTFSC  FD8.0
1D3C:  INCF   03,F
1D3E:  MOVFF  01,FE9
1D42:  MOVFF  03,FEA
1D46:  MOVLW  40
1D48:  MOVWF  FEF
....................             } 
....................             if (new_uep==0x06) {new_uep=0x0E;} 
1D4A:  MOVF   x91,W
1D4C:  SUBLW  06
1D4E:  BNZ   1D54
1D50:  MOVLW  0E
1D52:  MOVWF  x91
....................             if (usb_ep_tx_type[en]!=USB_ENABLE_ISOCHRONOUS) { 
1D54:  CLRF   03
1D56:  MOVF   x8E,W
1D58:  MOVFF  FF2,95
1D5C:  BCF    FF2.7
1D5E:  RCALL  189E
1D60:  BTFSC  x95.7
1D62:  BSF    FF2.7
1D64:  SUBLW  02
1D66:  BZ    1D6A
....................                new_uep|=0x10; 
1D68:  BSF    x91.4
....................             } 
....................             UEP(en)=new_uep; 
1D6A:  MOVLW  70
1D6C:  ADDWF  x8E,W
1D6E:  MOVWF  01
1D70:  MOVLW  0F
1D72:  MOVWF  03
1D74:  BTFSC  FD8.0
1D76:  INCF   03,F
1D78:  MOVFF  01,FE9
1D7C:  MOVFF  03,FEA
1D80:  MOVFF  91,FEF
....................          } 
1D84:  INCF   x8E,F
1D86:  BRA    1C14
....................       } 
.................... } 
1D88:  GOTO   1E1E (RETURN)
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... /******************************************************************************* 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt method), 
.................... /*       then you must call this function rapidly.  If there is more than 10ms 
.................... /*       latency the PC may think the USB device is stalled and disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this fuction. 
.................... /*       Also, goto usb_init() and remove the code that enables the USB interrupt. 
.................... /********************************************************************************/ 
.................... #int_usb 
.................... void usb_isr() { 
....................    if (usb_state==USB_STATE_DETACHED) return;   //should never happen, though 
*
2592:  MOVF   1E,F
2594:  BNZ   2598
2596:  BRA    25F6
....................    if (UIR) { 
2598:  MOVF   F68,F
259A:  BZ    25F6
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}  //activity detected.  (only enable after sleep) 
259C:  BTFSS  F68.2
259E:  BRA    25A8
25A0:  BTFSS  F69.2
25A2:  BRA    25A8
25A4:  GOTO   1A00
....................  
....................       if (UCON_SUSPND) return; 
25A8:  BTFSS  F6D.1
25AA:  BRA    25AE
25AC:  BRA    25F6
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
25AE:  BTFSS  F68.1
25B0:  BRA    25BA
25B2:  BTFSS  F69.1
25B4:  BRA    25BA
25B6:  GOTO   1A0A
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
25BA:  BTFSS  F68.0
25BC:  BRA    25C6
25BE:  BTFSS  F69.0
25C0:  BRA    25C6
25C2:  GOTO   1AAC
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
25C6:  BTFSS  F68.4
25C8:  BRA    25D2
25CA:  BTFSS  F69.4
25CC:  BRA    25D2
25CE:  GOTO   1AD6
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
25D2:  BTFSS  F68.6
25D4:  BRA    25DE
25D6:  BTFSS  F69.6
25D8:  BRA    25DE
25DA:  GOTO   1AE0
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
25DE:  BTFSS  F68.5
25E0:  BRA    25EA
25E2:  BTFSS  F69.5
25E4:  BRA    25EA
25E6:  GOTO   1AE6
....................  
....................       if (UIR_TRN && UIE_TRN) { 
25EA:  BTFSS  F68.3
25EC:  BRA    25F6
25EE:  BTFSS  F69.3
25F0:  BRA    25F6
....................          usb_isr_tok_dne(); 
25F2:  BRA    24C8
....................          UIR_TRN=0;    // clear the token done interrupt., 0x190.3 
25F4:  BCF    F68.3
....................       }    //a token has been detected (majority of isrs) 
....................    } 
.................... } 
....................  
.................... //SOF interrupt not handled.  user must add this depending on application 
25F6:  BCF    FA1.5
25F8:  GOTO   1858
.................... void usb_isr_sof(void) { 
....................    debug_usb(debug_putc,"\r\nSOF"); 
....................    UIR_SOF=0; 
*
1AE0:  BCF    F68.6
.................... } 
1AE2:  GOTO   25DE (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints 1 thru 15 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoints(void) { 
....................    int8 i; 
....................    for (i=1;i<16;i++) { 
*
1A62:  MOVLW  01
1A64:  MOVWF  x95
1A66:  MOVF   x95,W
1A68:  SUBLW  0F
1A6A:  BNC   1A88
....................       UEP(i)=ENDPT_DISABLED; 
1A6C:  MOVLW  70
1A6E:  ADDWF  x95,W
1A70:  MOVWF  01
1A72:  MOVLW  0F
1A74:  MOVWF  03
1A76:  BTFSC  FD8.0
1A78:  INCF   03,F
1A7A:  MOVFF  01,FE9
1A7E:  MOVFF  03,FEA
1A82:  CLRF   FEF
....................    } 
1A84:  INCF   x95,F
1A86:  BRA    1A66
....................    __usb_kbhit_status=0; 
1A88:  CLRF   1D
1A8A:  CLRF   1C
.................... } 
1A8C:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_rst() { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR=0; 
*
1AAC:  CLRF   F6A
....................    UIR=0; 
1AAE:  CLRF   F68
....................    UEIE=0x9F; 
1AB0:  MOVLW  9F
1AB2:  MOVWF  F6B
....................    UIE=STANDARD_INTS & ~__USB_UIF_ACTIVE; 
1AB4:  MOVLW  39
1AB6:  MOVWF  F69
....................  
....................    UADDR=0; 
1AB8:  CLRF   F6E
....................  
....................    usb_token_reset(); 
1ABA:  BRA    1A38
....................  
....................    usb_disable_endpoints(); 
1ABC:  RCALL  1A62
....................  
....................    UEP(0)=ENDPT_CONTROL | 0x10; 
1ABE:  MOVLW  16
1AC0:  MOVWF  F70
....................  
....................    while (UIR_TRN) { 
1AC2:  BTFSS  F68.3
1AC4:  BRA    1ACA
....................       UIR_TRN=0;    //do this to clear out the ustat fifo 
1AC6:  BCF    F68.3
....................    } 
1AC8:  BRA    1AC2
....................  
....................    UCON_PKTDIS=0; //SIE token and packet processing enabled 
1ACA:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
1ACC:  RCALL  1A8E
....................  
....................    usb_state=USB_STATE_DEFAULT; //put usb mcu into default state 
1ACE:  MOVLW  03
1AD0:  MOVWF  1E
.................... } 
1AD2:  GOTO   25C6 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void) { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
1A8E:  MOVLW  40
1A90:  MOVLB  4
1A92:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_BUFFER; 
1A94:  MOVLW  05
1A96:  MOVWF  x03
1A98:  CLRF   x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
1A9A:  MOVLW  88
1A9C:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
1A9E:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_BUFFER + (int16)USB_MAX_EP0_PACKET_LENGTH; 
1AA0:  MOVLW  05
1AA2:  MOVWF  x07
1AA4:  MOVLW  40
1AA6:  MOVWF  x06
.................... } 
1AA8:  MOVLB  0
1AAA:  RETLW  00
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr() { 
.................... #if USB_USE_ERROR_COUNTER 
....................    int ints; 
.................... #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) ) { //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) ) {  //increment crc5 error counter 
....................       debug_usbdebug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) ) {  //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) ) {  //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) ) {  //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) ) { //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
.................... #endif 
....................  
....................    UEIR=0; 
*
1A0A:  CLRF   F6A
....................    UIR_UERR=0; 
1A0C:  BCF    F68.1
.................... } 
1A0E:  GOTO   25BA (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_uidle() { 
....................    debug_usb(debug_putc,"I"); 
....................  
....................    UIE_ACTV=1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
1AD6:  BSF    F69.2
....................    UIR_IDLE=0; //clear idle interrupt flag 
1AD8:  BCF    F68.4
....................    UCON_SUSPND=1; //set suspend. we are now suspended 
1ADA:  BSF    F6D.1
.................... } 
1ADC:  GOTO   25D2 (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_activity() { 
....................    debug_usb(debug_putc,"A"); 
....................  
....................    UCON_SUSPND=0; //turn off low power suspending 
*
1A00:  BCF    F6D.1
....................    UIE_ACTV=0; //clear activity interupt enabling 
1A02:  BCF    F69.2
....................    UIR_ACTV=0; 
1A04:  BCF    F68.2
.................... } 
1A06:  GOTO   25A8 (RETURN)
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_stall(void) { 
....................    debug_usb(debug_putc,"S"); 
....................  
....................    if (bit_test(UEP(0),0)) { 
*
1AE6:  BTFSS  F70.0
1AE8:  BRA    1AEE
....................       usb_init_ep0_setup(); 
1AEA:  RCALL  1A8E
....................       bit_clear(UEP(0),0); 
1AEC:  BCF    F70.0
....................    } 
....................    UIR_STALL=0; 
1AEE:  BCF    F68.5
.................... } 
1AF0:  GOTO   25EA (RETURN)
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_isr_tok_dne() { 
....................    int8 en; 
....................  
....................    en=USTAT>>3; 
*
24C8:  RRCF   F6C,W
24CA:  MOVWF  x8C
24CC:  RRCF   x8C,F
24CE:  RRCF   x8C,F
24D0:  MOVLW  1F
24D2:  ANDWF  x8C,F
....................  
....................          debug_usb(debug_putc,"T "); 
....................          debug_usb(debug_putc,"%X ", USTAT); 
....................  
....................       if (USTAT==USTAT_OUT_SETUP_E0) {   //new out or setup token in the buffer 
24D4:  MOVF   F6C,F
24D6:  BNZ   254E
....................          debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................          if ((EP_BDxST_O(0) & 0x3C)==USB_PIC_PID_SETUP) { 
24D8:  MOVLB  4
24DA:  MOVF   x00,W
24DC:  ANDLW  3C
24DE:  SUBLW  34
24E0:  BNZ   2518
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
24E2:  CLRF   x04
....................  
....................             debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................             debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................             usb_isr_tok_setup_dne(); 
24E4:  MOVLB  0
24E6:  BRA    20F4
....................  
....................             //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) 
....................             //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone 
....................             //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit 
....................             if (__setup_0_tx_size==0xFF) 
24E8:  INCFSZ 1F,W
24EA:  BRA    24F6
....................                usb_flush_out(0,USB_DTS_STALL); 
24EC:  CLRF   x8D
24EE:  MOVLW  03
24F0:  MOVWF  x8E
24F2:  RCALL  211E
....................             else { 
24F4:  BRA    2512
....................                usb_flush_out(0,USB_DTS_TOGGLE); 
24F6:  CLRF   x8D
24F8:  MOVLW  02
24FA:  MOVWF  x8E
24FC:  RCALL  211E
....................                if (__setup_0_tx_size!=0xFE) { 
24FE:  MOVF   1F,W
2500:  SUBLW  FE
2502:  BZ    2512
....................                   usb_flush_in(0,__setup_0_tx_size,USB_DTS_USERX); 
2504:  CLRF   x99
2506:  CLRF   x9B
2508:  MOVFF  1F,9A
250C:  MOVLW  04
250E:  MOVWF  x9C
2510:  RCALL  2204
....................                } 
....................             } 
....................             UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
2512:  BCF    F6D.4
....................          } 
....................          else if ((EP_BDxST_O(0) & 0x3C)==USB_PIC_PID_OUT) { 
2514:  BRA    2548
2516:  MOVLB  4
2518:  MOVF   x00,W
251A:  ANDLW  3C
251C:  SUBLW  04
251E:  BNZ   254A
....................             usb_isr_tok_out_dne(0); 
2520:  MOVLB  0
2522:  CLRF   x8D
2524:  RCALL  2378
....................             usb_flush_out(0,USB_DTS_TOGGLE); 
2526:  CLRF   x8D
2528:  MOVLW  02
252A:  MOVWF  x8E
252C:  RCALL  211E
....................             if ((__setup_0_tx_size!=0xFE)&&(__setup_0_tx_size!=0xFF)) { 
252E:  MOVF   1F,W
2530:  SUBLW  FE
2532:  BZ    2548
2534:  INCFSZ 1F,W
2536:  BRA    253A
2538:  BRA    2548
....................                usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
253A:  CLRF   x99
253C:  CLRF   x9B
253E:  MOVFF  1F,9A
2542:  MOVLW  01
2544:  MOVWF  x9C
2546:  RCALL  2204
2548:  MOVLB  4
....................             } 
....................          } 
....................       } 
....................  
....................       else if (USTAT==USTAT_IN_E0) {   //pic -> host transfer completed 
254A:  BRA    258C
254C:  MOVLB  0
254E:  MOVF   F6C,W
2550:  SUBLW  04
2552:  BNZ   2578
....................          __setup_0_tx_size=0xFF; 
2554:  MOVLW  FF
2556:  MOVWF  1F
....................          usb_isr_tok_in_dne(0); 
2558:  CLRF   x8D
255A:  RCALL  24A6
....................          if (__setup_0_tx_size!=0xFF) 
255C:  INCFSZ 1F,W
255E:  BRA    2562
2560:  BRA    2572
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_TOGGLE); 
2562:  CLRF   x99
2564:  CLRF   x9B
2566:  MOVFF  1F,9A
256A:  MOVLW  02
256C:  MOVWF  x9C
256E:  RCALL  2204
....................          else 
2570:  BRA    2576
....................             usb_init_ep0_setup(); 
2572:  CALL   1A8E
....................       } 
....................  
....................       else { 
2576:  BRA    258A
....................          if (!bit_test(USTAT,2)) { 
2578:  BTFSC  F6C.2
257A:  BRA    2584
....................             usb_isr_tok_out_dne(en); 
257C:  MOVFF  8C,8D
2580:  RCALL  2378
....................          } 
....................          else { 
2582:  BRA    258A
....................             usb_isr_tok_in_dne(en); 
2584:  MOVFF  8C,8D
2588:  RCALL  24A6
258A:  MOVLB  4
....................          } 
....................       } 
.................... } 
258C:  MOVLB  0
258E:  GOTO   25F4 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(int len) { 
....................    __setup_0_tx_size=len; 
*
1AF4:  MOVFF  90,1F
.................... } 
1AF8:  RETLW  00
....................  
.................... void usb_request_get_data(void) { 
....................    __setup_0_tx_size=0xFE; 
*
204C:  MOVLW  FE
204E:  MOVWF  1F
.................... } 
2050:  RETLW  00
....................  
.................... void usb_request_stall(void) { 
....................    __setup_0_tx_size=0xFF; 
*
1AFA:  MOVLW  FF
1AFC:  MOVWF  1F
.................... } 
1AFE:  RETLW  00
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
....................  #endif 
.................... #else 
....................  #include <usbn960x.c>   //National 960x hardware layer for usb.c 
.................... #endif 
.................... #include <usb_desc_cdc.h>	//USB Configuration and Device descriptors for this UBS device 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_cdc.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's CDC Virtual COM Port driver (see usb_cdc.h)                 //// 
.................... ////                                                                   //// 
.................... //// Two examples are provided:                                        //// 
.................... ////      ex_usb_serial.c                                              //// 
.................... ////      ex_usb_serial2.c                                             //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// 10/28/05:                                                         //// 
.................... ////    Bulk endpoint sizes updated to allow more than 255 byte        //// 
.................... ////    packets.                                                       //// 
.................... ////    Changed device to USB 1.10                                     //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      67  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==0 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==1 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==2,3 
....................          2, //number of interfaces this device supports       ==4 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==5 
....................          0x00, //index of string descriptor for this configuration      ==6 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................          0x32, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)  ==8 
....................  
....................    //interface descriptor 0 (comm class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =9 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =10 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==11 
....................          0x00, //alternate setting     ==12 
....................          1, //number of endpoints   ==13 
....................          0x02, //class code, 02 = Comm Interface Class     ==14 
....................          0x02, //subclass code, 2 = Abstract     ==15 
....................          0x01, //protocol code, 1 = v.25ter      ==16 
....................          0x00, //index of string descriptor for interface      ==17 
....................  
....................    //class descriptor [functional header] 
....................          5, //length of descriptor    ==18 
....................          0x24, //dscriptor type (0x24 == )      ==19 
....................          0, //sub type (0=functional header) ==20 
....................          0x10,0x01, //      ==21,22 //cdc version 
....................  
....................    //class descriptor [acm header] 
....................          4, //length of descriptor    ==23 
....................          0x24, //dscriptor type (0x24 == )      ==24 
....................          2, //sub type (2=ACM)   ==25 
....................          2, //capabilities    ==26  //we support Set_Line_Coding, Set_Control_Line_State, Get_Line_Coding, and the notification Serial_State. 
....................  
....................    //class descriptor [union header] 
....................          5, //length of descriptor    ==27 
....................          0x24, //dscriptor type (0x24 == )      ==28 
....................          6, //sub type (6=union)    ==29 
....................          0, //master intf     ==30  //The interface number of the Communication or Dat a Cl ass interface, designated as the masteror controlling interface for the union. 
....................          1, //save intf0      ==31  //Interface number of first slave or associated interface in the union. * 
....................  
....................    //class descriptor [call mgmt header] 
....................          5, //length of descriptor    ==32 
....................          0x24, //dscriptor type (0x24 == )      ==33 
....................          1, //sub type (1=call mgmt)   ==34 
....................          0, //capabilities          ==35  //device does not handle call management itself 
....................          1, //data interface        ==36  //interface number of data class interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==37 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==38 
....................          USB_CDC_COMM_IN_ENDPOINT | 0x80, //endpoint number and direction 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==40 
....................          USB_CDC_COMM_IN_SIZE,0x00, //maximum packet size supported                  ==41,42 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==43 
....................  
....................    //interface descriptor 1 (data class interface) 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =44 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =45 
....................          0x01, //number defining this interface (IF we had more than one interface)    ==46 
....................          0x00, //alternate setting     ==47 
....................          2, //number of endpoints   ==48 
....................          0x0A, //class code, 0A = Data Interface Class     ==49 
....................          0x00, //subclass code      ==50 
....................          0x00, //protocol code      ==51 
....................          0x00, //index of string descriptor for interface      ==52 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==60 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==61 
....................          USB_CDC_DATA_OUT_ENDPOINT, //endpoint number and direction (0x02 = EP2 OUT)       ==62 
....................          0x02, //transfer type supported (0x02 is bulk)         ==63 
.................... //         make8(USB_CDC_DATA_OUT_SIZE,0),make8(USB_CDC_DATA_OUT_SIZE,1), //maximum packet size supported                  ==64, 65 
....................          USB_CDC_DATA_OUT_SIZE & 0xFF, (USB_CDC_DATA_OUT_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==64, 65 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==66 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==53 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==54 
....................          USB_CDC_DATA_IN_ENDPOINT | 0x80, //endpoint number and direction (0x82 = EP2 IN)       ==55 
....................          0x02, //transfer type supported (0x02 is bulk)         ==56 
.................... //         make8(USB_CDC_DATA_IN_SIZE,0),make8(USB_CDC_DATA_IN_SIZE,1), //maximum packet size supported                  ==57, 58 
....................          USB_CDC_DATA_IN_SIZE & 0xFF, (USB_CDC_DATA_IN_SIZE >> 8) & 0xFF, //maximum packet size supported                  ==64, 65 
....................          250,  //polling interval, in ms.  (cant be smaller than 10)      ==59 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   2 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={2}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int16 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][USB_MAX_NUM_INTERFACES][4]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1-4 
....................          18,23,27,32, 
....................       //interface 1 
....................          //no classes for this interface 
....................          0xFFFF,0xFFFF,0xFFFF,0xFFFF 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==0 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==1 
....................          0x10,0x01, //usb version in bcd  ==2,3 
....................          0x02, //class code. 0x02=Communication Device Class ==4 
....................          0x00, //subclass code ==5 
....................          0x00, //protocol code ==6 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==7 
....................          0x61,0x04, //vendor id (0x04D8 is Microchip, or is it 0x0461 ??)  ==8,9 
....................          0x33,0x00, //product id   ==10,11 
....................          0x00,0x01, //device release number  ==12,13 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==14 
....................          0x02, //index of string descriptor of the product  ==15 
....................          0x00, //index of string descriptor of serial number  ==16 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==17 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 
....................          30, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................          ' ',0, 
....................          'R',0, 
....................          'S',0, 
....................          '2',0, 
....................          '3',0, 
....................          '2',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'e',0, 
....................          'm',0, 
....................          'o',0 
.................... }; 
....................  
.................... #ENDIF 
....................  
.................... #include <usb.c>        //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... //// Many settings important to the USB API are defined in usb.h.      //// 
.................... //// See the documentation in usb.h about these settings.              //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The following functions are of use to  //// 
.................... //// the user (for more docs on the functions, read the comments at    //// 
.................... //// each function):                                                   //// 
.................... ////                                                                   //// 
.................... ////    **********************  FUNCTIONS  ***********************     //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral until you //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit() - Returns true if OUT endpoint contains data from     //// 
.................... ////               host.                                               //// 
.................... ////                                                                   //// 
.................... //// usb_puts() - Sends a multiple packet message to the host          //// 
.................... ////                                                                   //// 
.................... //// usb_gets() - Gets multiple packets from the host                  //// 
.................... ////                                                                   //// 
.................... //// The rest of the functions in this file are part of the USB        //// 
.................... //// interrupt service routine and are not meant to be called by the   //// 
.................... //// user.                                                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must include the following functions:                             //// 
.................... ////                                                                   //// 
.................... //// void usb_stall_ep(int8 endpoint);                                 //// 
.................... //// void usb_unstall_ep(int8 endpoint);                               //// 
.................... //// int1 usb_endpoint_stalled(int8 endpoint);                         //// 
.................... //// void usb_set_address(int8 address);                               //// 
.................... //// void usb_set_configured(int config);                              //// 
.................... //// int8 usb_get_packet(int8 endpoint, int8 * ptr, int8 max);         //// 
.................... //// int1 usb_put_packet(int endpoint, int * ptr, int len, USB_DTS_BIT toggle); //// 
.................... //// void usb_request_send_response(int8 len);                                //// 
.................... //// int1 usb_kbhit(int8 endpoint);                                    //// 
.................... ////                                                                   //// 
.................... //// CCS provides a USB peripheral hardware layer for PIC16C7x5        //// 
.................... //// (pic_usb.h), 18Fxx5x (pic18_usb.h) and National's USBN960x        //// 
.................... //// (usbn960x.c).  See these files for more documentation.            //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #define usb_kbhit(x) bit_test(__usb_kbhit_status,x) 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: Use this to see if device is configured / enumerated. 
.................... /***************************************************************/ 
.................... #define usb_enumerated() (USB_stack_status.curr_config) 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void) { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts(endpoint, *ptr, len, timeout) 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before timeout. 
.................... /*                   set to 0 for no timeout. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  If sending 
.................... /*          only one packet it is more effecient to use only usb_put_packet() 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout) { 
....................    int16 i=0; 
....................    int1 res; 
....................    int16 this_packet_len; 
....................    int16 packet_size; 
....................    int32 timeout_1us; 
....................  
....................    packet_size=usb_ep_tx_size[endpoint]; 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len=packet_size;} 
....................       else {this_packet_len=len-i;} 
....................       do { 
....................          res=usb_put_packet(endpoint,ptr + i,this_packet_len,USB_DTS_TOGGLE);   //send 64 byte packets 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i+=packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res=usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before timeout. 
.................... /*                   set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /* NOTE: NOT THOUROUGHLY TESTED.  I AM NOT EVEN SURE IF THIS IS A GOOD IDEA 
.................... /* 
.................... /*****************************************************************************/ 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout) { 
....................    int16 ret=0; 
....................    int16 to; 
....................    int16 len; 
....................    int16 packet_size; 
....................    int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output: modifies global variables USB_Interface[], in[], usb_getdesc_ptr, 
.................... /*         usb_getdesc_len, USB_status_device, USB_dev_req 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset() { 
....................    int i; 
....................  
....................  
....................  
....................       for (i=0;i<USB_MAX_NUM_INTERFACES;i++) { 
*
1A38:  CLRF   x8C
1A3A:  MOVF   x8C,W
1A3C:  SUBLW  01
1A3E:  BNC   1A54
....................          USB_Interface[i]=0;   //reset each interface to default 
1A40:  CLRF   03
1A42:  MOVF   x8C,W
1A44:  ADDLW  27
1A46:  MOVWF  FE9
1A48:  MOVLW  00
1A4A:  ADDWFC 03,W
1A4C:  MOVWF  FEA
1A4E:  CLRF   FEF
....................       } 
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) { 
....................        hid_protocol[i]=1; 
....................    } 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
1A50:  INCF   x8C,F
1A52:  BRA    1A3A
....................    usb_cdc_init(); 
1A54:  BRA    1A12
....................   #endif 
....................  
....................     USB_stack_status.curr_config=0;      //unconfigured device 
1A56:  CLRF   19
....................  
....................     USB_stack_status.status_device=1;    //previous state.  init at none 
1A58:  MOVLW  01
1A5A:  MOVWF  1A
....................     USB_stack_status.dev_req=NONE;       //previous token request state.  init at none 
1A5C:  CLRF   18
.................... } 
1A5E:  GOTO   1ABC (RETURN)
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... // 
.................... int1 usb_endpoint_is_valid(int8 endpoint) { 
....................    int1 direction; 
....................    direction = bit_test(endpoint,7); 
*
1EC4:  BCF    x8E.0
1EC6:  BTFSC  x8D.7
1EC8:  BSF    x8E.0
....................    endpoint &= 0x7F; 
1ECA:  BCF    x8D.7
....................    if (direction) { //IN 
1ECC:  BTFSS  x8E.0
1ECE:  BRA    1EF0
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
1ED0:  CLRF   03
1ED2:  MOVF   x8D,W
1ED4:  MOVFF  FF2,8F
1ED8:  BCF    FF2.7
1EDA:  RCALL  189E
1EDC:  BTFSC  x8F.7
1EDE:  BSF    FF2.7
1EE0:  XORLW  00
1EE2:  BNZ   1EE8
1EE4:  MOVLW  00
1EE6:  BRA    1EEA
1EE8:  MOVLW  01
1EEA:  MOVWF  01
1EEC:  BRA    1F0E
....................    } 
....................    else {   //OUT 
1EEE:  BRA    1F0E
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
1EF0:  CLRF   03
1EF2:  MOVF   x8D,W
1EF4:  MOVFF  FF2,8F
1EF8:  BCF    FF2.7
1EFA:  RCALL  18BE
1EFC:  BTFSC  x8F.7
1EFE:  BSF    FF2.7
1F00:  XORLW  00
1F02:  BNZ   1F08
1F04:  MOVLW  00
1F06:  BRA    1F0A
1F08:  MOVLW  01
1F0A:  MOVWF  01
1F0C:  BRA    1F0E
....................    } 
.................... } 
1F0E:  GOTO   1FF2 (RETURN)
....................  
.................... ///---------------------------------------------------------------/// 
.................... /// Processing Message stages is the biggest portion of the ISR   /// 
.................... ///---------------------------------------------------------------/// 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token.  Should be 0. 
.................... /* 
.................... /* Summary: When receiving an IN token from the PC on endpoint 0 that means the 
.................... /*          host is asking for a response from a setup token, or the next packet 
.................... /*          from a currently processing token.  (For example, a 24 byte descriptor 
.................... /*          would require 3 IN tokens if the packet size is 8 bytes.)  USB_dev_req 
.................... /*          is a global variable that defines what setup token we are currently processing. 
.................... /* 
.................... /* Part of USB interrupt service routine. 
.................... /* Only checks endpoint 0. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
24A6:  MOVF   x8D,F
24A8:  BNZ   24BE
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
24AA:  DECFSZ 18,W
24AC:  BRA    24B4
24AE:  CALL   1B00
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
24B2:  BRA    24BC
24B4:  MOVF   18,W
24B6:  SUBLW  02
24B8:  BNZ   24BC
24BA:  BRA    23C0
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
24BC:  BRA    24C6
24BE:  MOVF   x8D,W
24C0:  SUBLW  02
24C2:  BNZ   24C6
....................       usb_isr_tok_in_cdc_data_dne(); 
24C4:  BRA    2498
....................   } 
....................   #endif 
.................... } 
24C6:  RETLW  00
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data. 
.................... /*        This code doesn't allow reception of data from EP0. (Add later) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy incoming 
.................... /*          to the pic), but not out setup tokens.  Data is placed into a 
.................... /*          a buffer if it is empty, and the rx flag is set.  If the buffer 
.................... /*          is not empty then the overrun bit of that EP status byte is set it. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint) { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
2378:  MOVF   x8D,F
237A:  BNZ   2380
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
237C:  BRA    22E2
....................      #else 
....................       usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
237E:  BRA    23A8
2380:  MOVF   x8D,W
2382:  SUBLW  02
2384:  BNZ   238A
....................       usb_isr_tok_out_cdc_data_dne(); 
2386:  BRA    2366
....................    } 
....................   #endif 
....................    else { 
2388:  BRA    23A8
....................       bit_set(__usb_kbhit_status,endpoint); 
238A:  CLRF   03
238C:  MOVLW  01
238E:  MOVWF  02
2390:  MOVF   x8D,W
2392:  MOVWF  00
2394:  BZ    23A0
2396:  BCF    FD8.0
2398:  RLCF   02,F
239A:  RLCF   03,F
239C:  DECFSZ 00,F
239E:  BRA    2396
23A0:  MOVF   02,W
23A2:  IORWF  1C,F
23A4:  MOVF   03,W
23A6:  IORWF  1D,F
....................    } 
.................... } 
23A8:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
.................... ////// HUGE - most of our code is to read setup messages //// 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the 8 bytes of the setup packet. 
.................... /* 
.................... /* Output: The DTS we expect for the next packet on OUT 0. 
.................... /* 
.................... /* Summary: This function is the start of code that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration, Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[8] now contains setup data packet, which has the following records 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
....................                                        (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet 
.................... /*                        for host-to-device, this exactly how many bytes in data packet 
.................... /*                        for device-to-host, this is the maximum bytes that can fit one packet 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void) { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
20F4:  CLRF   18
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
20F6:  MOVLB  5
20F8:  MOVF   x00,W
20FA:  ANDLW  7F
20FC:  MOVLB  0
20FE:  BZ    210E
2100:  XORLW  01
2102:  BZ    2110
2104:  XORLW  03
2106:  BZ    2112
2108:  XORLW  23
210A:  BZ    2114
210C:  BRA    2116
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
210E:  BRA    1D8C
....................          break; 
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
2110:  BRA    1E2E
....................          break; 
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
2112:  BRA    1FEC
....................          break; 
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
2114:  BRA    2052
....................          break; 
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
2116:  RCALL  1AFA
....................          break; 
2118:  BRA    211A
....................    } 
.................... } 
211A:  GOTO   24E8 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
1D8C:  MOVLB  5
1D8E:  MOVF   x01,W
1D90:  MOVLB  0
1D92:  BZ    1DAE
1D94:  XORLW  01
1D96:  BZ    1DC0
1D98:  XORLW  02
1D9A:  BZ    1DD8
1D9C:  XORLW  06
1D9E:  BZ    1DEE
1DA0:  XORLW  03
1DA2:  BZ    1DFC
1DA4:  XORLW  0E
1DA6:  BZ    1DFE
1DA8:  XORLW  01
1DAA:  BZ    1E0A
1DAC:  BRA    1E26
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
1DAE:  MOVFF  1A,540
....................             usb_ep0_tx_buffer[1]=0; 
1DB2:  MOVLB  5
1DB4:  CLRF   x41
....................             usb_request_send_response(2); 
1DB6:  MOVLW  02
1DB8:  MOVLB  0
1DBA:  MOVWF  x90
1DBC:  RCALL  1AF4
....................             break; 
1DBE:  BRA    1E2A
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
1DC0:  MOVLB  5
1DC2:  DECFSZ x02,W
1DC4:  BRA    1DD2
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
1DC6:  MOVLW  01
1DC8:  ANDWF  1A,F
....................                usb_put_0len_0(); 
1DCA:  MOVLB  0
1DCC:  CLRF   x90
1DCE:  RCALL  1AF4
....................             } 
....................             else 
1DD0:  BRA    1DD6
....................                usb_request_stall(); 
1DD2:  MOVLB  0
1DD4:  RCALL  1AFA
....................             break; 
1DD6:  BRA    1E2A
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
1DD8:  MOVLB  5
1DDA:  DECFSZ x02,W
1DDC:  BRA    1DE8
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
1DDE:  BSF    1A.1
....................                usb_put_0len_0(); 
1DE0:  MOVLB  0
1DE2:  CLRF   x90
1DE4:  RCALL  1AF4
....................             } 
....................             else 
1DE6:  BRA    1DEC
....................                usb_request_stall(); 
1DE8:  MOVLB  0
1DEA:  RCALL  1AFA
....................             break; 
1DEC:  BRA    1E2A
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
1DEE:  MOVLW  02
1DF0:  MOVWF  18
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
1DF2:  MOVFF  502,23
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................          	USB_stack_status.curr_config=0;	// make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
1DF6:  CLRF   x90
1DF8:  RCALL  1AF4
....................             break; 
1DFA:  BRA    1E2A
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
1DFC:  BRA    1B84
....................             break; 
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
1DFE:  MOVFF  19,540
....................             usb_request_send_response(1); 
1E02:  MOVLW  01
1E04:  MOVWF  x90
1E06:  RCALL  1AF4
....................             break; 
1E08:  BRA    1E2A
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
1E0A:  MOVLB  5
1E0C:  MOVF   x02,W
1E0E:  SUBLW  01
1E10:  BNC   1E22
....................                debug_usb(debug_putc,"SC"); 
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
1E12:  MOVFF  502,19
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
1E16:  MOVFF  502,8D
1E1A:  MOVLB  0
1E1C:  BRA    1BFA
....................                usb_put_0len_0(); 
1E1E:  CLRF   x90
1E20:  RCALL  1AF4
....................             } 
....................             break; 
1E22:  MOVLB  0
1E24:  BRA    1E2A
....................  
....................       default: 
....................             usb_request_stall(); 
1E26:  RCALL  1AFA
....................             break; 
1E28:  BRA    1E2A
....................    } 
.................... } 
1E2A:  GOTO   211A (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
1E2E:  MOVFF  19,8D
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
1E32:  MOVLB  5
1E34:  MOVF   x01,W
1E36:  MOVLB  0
1E38:  BZ    1E44
1E3A:  XORLW  0A
1E3C:  BZ    1E54
1E3E:  XORLW  01
1E40:  BZ    1E98
1E42:  BRA    1EBC
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
1E44:  MOVLB  5
1E46:  CLRF   x40
....................             usb_ep0_tx_buffer[1]=0; 
1E48:  CLRF   x41
....................             usb_request_send_response(2); 
1E4A:  MOVLW  02
1E4C:  MOVLB  0
1E4E:  MOVWF  x90
1E50:  RCALL  1AF4
....................             break; 
1E52:  BRA    1EC0
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
1E54:  MOVF   x8D,F
1E56:  BZ    1E94
1E58:  MOVLW  01
1E5A:  SUBWF  x8D,W
1E5C:  CLRF   03
1E5E:  MOVFF  FF2,8F
1E62:  BCF    FF2.7
1E64:  RCALL  1992
1E66:  BTFSC  x8F.7
1E68:  BSF    FF2.7
1E6A:  MOVWF  01
1E6C:  MOVLB  5
1E6E:  SUBWF  x04,W
1E70:  BTFSS  FD8.0
1E72:  BRA    1E78
1E74:  MOVLB  0
1E76:  BRA    1E94
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
1E78:  CLRF   03
1E7A:  MOVF   x04,W
1E7C:  ADDLW  27
1E7E:  MOVWF  FE9
1E80:  MOVLW  00
1E82:  ADDWFC 03,W
1E84:  MOVWF  FEA
1E86:  MOVFF  FEF,540
....................                usb_request_send_response(1);; //send byte back 
1E8A:  MOVLW  01
1E8C:  MOVLB  0
1E8E:  MOVWF  x90
1E90:  RCALL  1AF4
....................             } 
....................             else 
1E92:  BRA    1E96
....................                usb_request_stall(); 
1E94:  RCALL  1AFA
....................             break; 
1E96:  BRA    1EC0
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
1E98:  MOVF   x8D,F
1E9A:  BZ    1EB8
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
1E9C:  CLRF   03
1E9E:  MOVLB  5
1EA0:  MOVF   x04,W
1EA2:  ADDLW  27
1EA4:  MOVWF  FE9
1EA6:  MOVLW  00
1EA8:  ADDWFC 03,W
1EAA:  MOVWF  FEA
1EAC:  MOVFF  502,FEF
....................                usb_put_0len_0(); 
1EB0:  MOVLB  0
1EB2:  CLRF   x90
1EB4:  RCALL  1AF4
....................             } 
....................             else 
1EB6:  BRA    1EBA
....................                usb_request_stall(); 
1EB8:  RCALL  1AFA
....................             break; 
1EBA:  BRA    1EC0
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
1EBC:  RCALL  1AFA
....................             break; 
1EBE:  BRA    1EC0
....................    } 
.................... } 
1EC0:  GOTO   211A (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
1FEC:  MOVFF  504,8D
1FF0:  BRA    1EC4
1FF2:  MOVF   01,F
1FF4:  BZ    2048
....................       switch(usb_ep0_rx_buffer[1]) { 
1FF6:  MOVLB  5
1FF8:  MOVF   x01,W
1FFA:  XORLW  01
1FFC:  MOVLB  0
1FFE:  BZ    200A
2000:  XORLW  02
2002:  BZ    2016
2004:  XORLW  03
2006:  BZ    2022
2008:  BRA    2044
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
200A:  MOVFF  504,8D
200E:  BRA    1F12
....................                usb_put_0len_0(); 
2010:  CLRF   x90
2012:  RCALL  1AF4
....................                break; 
2014:  BRA    2048
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
2016:  MOVFF  504,8D
201A:  BRA    1F54
....................                      usb_put_0len_0(); 
201C:  CLRF   x90
201E:  RCALL  1AF4
....................                      break; 
2020:  BRA    2048
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
2022:  MOVLB  5
2024:  CLRF   x40
....................                usb_ep0_tx_buffer[1]=0; 
2026:  CLRF   x41
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
2028:  MOVFF  504,8D
202C:  MOVLB  0
202E:  BRA    1F98
2030:  MOVF   01,F
2032:  BZ    203C
....................                   usb_ep0_tx_buffer[0]=1; 
2034:  MOVLW  01
2036:  MOVLB  5
2038:  MOVWF  x40
203A:  MOVLB  0
....................                } 
....................                usb_request_send_response(2); 
203C:  MOVLW  02
203E:  MOVWF  x90
2040:  RCALL  1AF4
....................                break; 
2042:  BRA    2048
....................  
....................          default: 
....................             usb_request_stall(); 
2044:  RCALL  1AFA
....................             break; 
2046:  BRA    2048
....................       } 
....................    } 
.................... } 
2048:  GOTO   211A (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
1B84:  CLRF   24
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
1B86:  CLRF   1B
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
1B88:  MOVLB  5
1B8A:  MOVF   x03,W
1B8C:  XORLW  01
1B8E:  MOVLB  0
1B90:  BZ    1B9C
1B92:  XORLW  03
1B94:  BZ    1BA6
1B96:  XORLW  01
1B98:  BZ    1BAC
1B9A:  BRA    1BDA
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
1B9C:  MOVLW  12
1B9E:  MOVWF  26
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
1BA0:  MOVLW  03
1BA2:  MOVWF  1B
....................             break; 
1BA4:  BRA    1BDE
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
1BA6:  MOVLW  43
1BA8:  MOVWF  26
....................             break; 
1BAA:  BRA    1BDE
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
1BAC:  MOVLW  02
1BAE:  MOVWF  1B
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
1BB0:  CLRF   03
1BB2:  MOVLB  5
1BB4:  MOVF   x02,W
1BB6:  ADDLW  20
1BB8:  MOVWF  FE9
1BBA:  MOVLW  00
1BBC:  ADDWFC 03,W
1BBE:  MOVWF  FEA
1BC0:  MOVFF  FEF,24
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
1BC4:  CLRF   03
1BC6:  MOVF   24,W
1BC8:  MOVFF  FF2,8D
1BCC:  BCF    FF2.7
1BCE:  MOVLB  0
1BD0:  RCALL  19C6
1BD2:  BTFSC  x8D.7
1BD4:  BSF    FF2.7
1BD6:  MOVWF  26
....................             break; 
1BD8:  BRA    1BDE
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][0]; 
....................             if (usb_getdesc_ptr!=0xFF) { 
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
....................  
....................  
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
1BDA:  RCALL  1AFA
....................             return; 
1BDC:  BRA    1BF6
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
1BDE:  MOVLB  5
1BE0:  MOVF   x07,F
1BE2:  BNZ   1BEE
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
1BE4:  MOVF   26,W
1BE6:  SUBWF  x06,W
1BE8:  BC    1BEE
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
1BEA:  MOVFF  506,26
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
1BEE:  MOVLW  01
1BF0:  MOVWF  18
....................    usb_copy_desc_seg_to_ep(); 
1BF2:  MOVLB  0
1BF4:  RCALL  1B00
.................... } 
1BF6:  GOTO   1E2A (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
.................... 	USB_stack_status.curr_config=0;	// make sure current configuration is 0 
*
23C0:  CLRF   19
....................  
....................    #ifdef __PIC__ 
.................... 	USB_stack_status.dev_req=NONE;  // no request pending 
23C2:  CLRF   18
....................    usb_set_address(USB_address_pending); 
23C4:  MOVFF  23,8E
23C8:  BRA    23AA
....................    #endif 
.................... } 
23CA:  GOTO   24BC (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
....................    int i=0; 
*
1B00:  CLRF   x8E
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
1B02:  MOVF   26,F
1B04:  BZ    1B70
1B06:  MOVF   x8E,W
1B08:  SUBLW  3F
1B0A:  BNC   1B70
....................       switch(USB_stack_status.getdesc_type) { 
1B0C:  MOVF   1B,W
1B0E:  BZ    1B1A
1B10:  XORLW  02
1B12:  BZ    1B2E
1B14:  XORLW  01
1B16:  BZ    1B42
1B18:  BRA    1B56
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
1B1A:  CLRF   03
1B1C:  MOVF   24,W
1B1E:  MOVFF  FF2,90
1B22:  BCF    FF2.7
1B24:  RCALL  193E
1B26:  BTFSC  x90.7
1B28:  BSF    FF2.7
1B2A:  MOVWF  x8F
....................             break; 
1B2C:  BRA    1B56
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
1B2E:  CLRF   03
1B30:  MOVF   24,W
1B32:  MOVFF  FF2,90
1B36:  BCF    FF2.7
1B38:  RCALL  19C6
1B3A:  BTFSC  x90.7
1B3C:  BSF    FF2.7
1B3E:  MOVWF  x8F
....................             break; 
1B40:  BRA    1B56
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
1B42:  CLRF   03
1B44:  MOVF   24,W
1B46:  MOVFF  FF2,90
1B4A:  BCF    FF2.7
1B4C:  RCALL  19A4
1B4E:  BTFSC  x90.7
1B50:  BSF    FF2.7
1B52:  MOVWF  x8F
....................             break; 
1B54:  BRA    1B56
....................       } 
....................       usb_getdesc_ptr++; 
1B56:  INCF   24,F
....................       usb_getdesc_len--; 
1B58:  DECF   26,F
....................       usb_ep0_tx_buffer[i++]=c; 
1B5A:  MOVF   x8E,W
1B5C:  INCF   x8E,F
1B5E:  CLRF   03
1B60:  ADDLW  40
1B62:  MOVWF  FE9
1B64:  MOVLW  05
1B66:  ADDWFC 03,W
1B68:  MOVWF  FEA
1B6A:  MOVFF  8F,FEF
....................    } 
1B6E:  BRA    1B02
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
1B70:  MOVF   26,F
1B72:  BNZ   1B7C
1B74:  MOVF   x8E,W
1B76:  SUBLW  40
1B78:  BZ    1B7C
....................          USB_stack_status.dev_req = NONE; 
1B7A:  CLRF   18
....................    } 
....................  
....................    usb_request_send_response(i); 
1B7C:  MOVFF  8E,90
1B80:  RCALL  1AF4
.................... } 
1B82:  RETLW  00
....................  
.................... #ENDIF 
....................  
....................  
.................... struct { 
....................         int32   dwDTERrate;   //data terminal rate, in bits per second 
....................         int8    bCharFormat;  //num of stop bits (0=1, 1=1.5, 2=2) 
....................         int8    bParityType;  //parity (0=none, 1=odd, 2=even, 3=mark, 4=space) 
....................         int8    bDataBits;    //data bits (5,6,7,8 or 16) 
.................... } usb_cdc_line_coding; 
....................  
.................... //length of time, in ms, of break signal as we received in a SendBreak message. 
.................... //if ==0xFFFF, send break signal until we receive a 0x0000. 
.................... int16 usb_cdc_break; 
....................  
.................... int8 usb_cdc_encapsulated_cmd[8]; 
....................  
.................... int8 usb_cdc_put_buffer[USB_CDC_DATA_IN_SIZE]; 
.................... int1 usb_cdc_put_buffer_free; 
.................... #if USB_CDC_DATA_IN_SIZE>=0x100 
....................  int16 usb_cdc_put_buffer_nextin=0; 
.................... // int16 usb_cdc_last_data_packet_size; 
.................... #else 
....................  int8 usb_cdc_put_buffer_nextin=0; 
.................... // int8 usb_cdc_last_data_packet_size; 
.................... #endif 
....................  
.................... struct { 
....................    int1 got; 
....................   #if USB_CDC_DATA_OUT_SIZE>=0x100 
....................    int16 len; 
....................    int16 index; 
....................   #else 
....................    int8 len; 
....................    int8 index; 
....................   #endif 
.................... } usb_cdc_get_buffer_status; 
....................  
.................... int8 usb_cdc_get_buffer_status_buffer[USB_CDC_DATA_OUT_SIZE]; 
.................... #if (defined(__PIC__)) 
....................  #if __PIC__ 
....................   //#locate usb_cdc_get_buffer_status_buffer=0x500+(2*USB_MAX_EP0_PACKET_LENGTH)+USB_CDC_COMM_IN_SIZE 
....................   #if USB_MAX_EP0_PACKET_LENGTH==8 
....................      #locate usb_cdc_get_buffer_status_buffer=0x500+24 
....................   #elif USB_MAX_EP0_PACKET_LENGTH==64 
....................      #locate usb_cdc_get_buffer_status_buffer=0x500+136 
....................   #else 
....................    #error CCS BUG WONT LET ME USE MATH IN LOCATE 
....................   #endif 
....................  #endif 
.................... #endif 
....................  
.................... int1 usb_cdc_got_set_line_coding; 
....................  
.................... struct  { 
....................    int1 dte_present; //1=DTE present, 0=DTE not present 
....................    int1 active;      //1=activate carrier, 0=deactivate carrier 
....................    int reserved:6; 
.................... } usb_cdc_carrier; 
....................  
.................... enum {USB_CDC_OUT_NOTHING=0, USB_CDC_OUT_COMMAND=1, USB_CDC_OUT_LINECODING=2, USB_CDC_WAIT_0LEN=3} __usb_cdc_state=0; 
....................  
.................... #byte INTCON=0xFF2 
.................... #bit INT_GIE=INTCON.7 
....................  
.................... //handle OUT token done interrupt on endpoint 0 [read encapsulated cmd and line coding data] 
.................... void usb_isr_tok_out_cdc_control_dne(void) { 
....................    debug_usb(debug_putc,"CDC %X ",__usb_cdc_state); 
....................  
....................    switch (__usb_cdc_state) { 
*
22E2:  MOVF   x80,W
22E4:  XORLW  01
22E6:  BZ    22EE
22E8:  XORLW  03
22EA:  BZ    2310
22EC:  BRA    2332
....................       //printf(putc_tbe,"@%X@\r\n", __usb_cdc_state); 
....................       case USB_CDC_OUT_COMMAND: 
....................          //usb_get_packet(0, usb_cdc_encapsulated_cmd, 8); 
....................          memcpy(usb_cdc_encapsulated_cmd, usb_ep0_rx_buffer,8); 
22EE:  CLRF   FEA
22F0:  MOVLW  32
22F2:  MOVWF  FE9
22F4:  MOVLW  05
22F6:  MOVWF  FE2
22F8:  CLRF   FE1
22FA:  MOVLW  08
22FC:  MOVWF  01
22FE:  MOVFF  FE6,FEE
2302:  DECFSZ 01,F
2304:  BRA    22FE
....................         #if USB_MAX_EP0_PACKET_LENGTH==8 
....................          __usb_cdc_state=USB_CDC_WAIT_0LEN; 
....................          usb_request_get_data(); 
....................         #else 
....................          usb_put_0len_0(); 
2306:  CLRF   x90
2308:  CALL   1AF4
....................          __usb_cdc_state=0; 
230C:  CLRF   x80
....................         #endif 
....................          break; 
230E:  BRA    233A
....................  
....................     #if USB_MAX_EP0_PACKET_LENGTH==8 
....................       case USB_CDC_WAIT_0LEN: 
....................          usb_put_0len_0(); 
....................          __usb_cdc_state=0; 
....................          break; 
....................     #endif 
....................  
....................       case USB_CDC_OUT_LINECODING: 
....................          //usb_get_packet(0, &usb_cdc_line_coding, 7); 
....................          //printf(putc_tbe,"\r\n!GSLC FIN!\r\n"); 
....................          memcpy(&usb_cdc_line_coding, usb_ep0_rx_buffer,7); 
2310:  CLRF   FEA
2312:  MOVLW  29
2314:  MOVWF  FE9
2316:  MOVLW  05
2318:  MOVWF  FE2
231A:  CLRF   FE1
231C:  MOVLW  07
231E:  MOVWF  01
2320:  MOVFF  FE6,FEE
2324:  DECFSZ 01,F
2326:  BRA    2320
....................          __usb_cdc_state=0; 
2328:  CLRF   x80
....................          usb_put_0len_0(); 
232A:  CLRF   x90
232C:  CALL   1AF4
....................          break; 
2330:  BRA    233A
....................  
....................       default: 
....................          __usb_cdc_state=0; 
2332:  CLRF   x80
....................          usb_init_ep0_setup(); 
2334:  CALL   1A8E
....................          break; 
2338:  BRA    233A
....................    } 
.................... } 
233A:  GOTO   237E (RETURN)
....................  
.................... //handle IN token on 0 (setup packet) 
.................... void usb_isr_tkn_cdc(void) { 
....................    //make sure the request goes to a CDC interface 
....................    if ((usb_ep0_rx_buffer[4] == 1) || (usb_ep0_rx_buffer[4] == 0)) { 
*
2052:  MOVLB  5
2054:  DECFSZ x04,W
2056:  BRA    205A
2058:  BRA    205E
205A:  MOVF   x04,F
205C:  BNZ   20EE
....................       //printf(putc_tbe,"!%X!\r\n", usb_ep0_rx_buffer[1]); 
....................       switch(usb_ep0_rx_buffer[1]) { 
205E:  MOVF   x01,W
2060:  MOVLB  0
2062:  BZ    207A
2064:  XORLW  01
2066:  BZ    2082
2068:  XORLW  21
206A:  BZ    20A4
206C:  XORLW  01
206E:  BZ    20AE
2070:  XORLW  03
2072:  BZ    20D0
2074:  XORLW  01
2076:  BZ    20DA
2078:  BRA    20E8
....................          case 0x00:  //send_encapsulated_command 
....................             __usb_cdc_state=USB_CDC_OUT_COMMAND; 
207A:  MOVLW  01
207C:  MOVWF  x80
....................             usb_request_get_data(); 
207E:  RCALL  204C
....................             break; 
2080:  BRA    20EC
....................  
....................          case 0x01:  //get_encapsulated_command 
....................             memcpy(usb_ep0_tx_buffer, usb_cdc_encapsulated_cmd, 8); 
2082:  MOVLW  05
2084:  MOVWF  FEA
2086:  MOVLW  40
2088:  MOVWF  FE9
208A:  CLRF   FE2
208C:  MOVLW  32
208E:  MOVWF  FE1
2090:  MOVLW  08
2092:  MOVWF  01
2094:  MOVFF  FE6,FEE
2098:  DECFSZ 01,F
209A:  BRA    2094
....................             usb_request_send_response(usb_ep0_rx_buffer[6]);  //send wLength bytes 
209C:  MOVFF  506,90
20A0:  RCALL  1AF4
....................             break; 
20A2:  BRA    20EC
....................  
....................          case 0x20:  //set_line_coding 
....................             debug_usb(debug_putc,"!GSLC!"); 
....................             __usb_cdc_state=USB_CDC_OUT_LINECODING; 
20A4:  MOVLW  02
20A6:  MOVWF  x80
....................             usb_cdc_got_set_line_coding=TRUE; 
20A8:  BSF    x7A.1
....................             usb_request_get_data(); 
20AA:  RCALL  204C
....................             break; 
20AC:  BRA    20EC
....................  
....................          case 0x21:  //get_line_coding 
....................             memcpy(usb_ep0_tx_buffer, &usb_cdc_line_coding, sizeof(usb_cdc_line_coding)); 
20AE:  MOVLW  05
20B0:  MOVWF  FEA
20B2:  MOVLW  40
20B4:  MOVWF  FE9
20B6:  CLRF   FE2
20B8:  MOVLW  29
20BA:  MOVWF  FE1
20BC:  MOVLW  07
20BE:  MOVWF  01
20C0:  MOVFF  FE6,FEE
20C4:  DECFSZ 01,F
20C6:  BRA    20C0
....................             usb_request_send_response(sizeof(usb_cdc_line_coding)); //send wLength bytes 
20C8:  MOVLW  07
20CA:  MOVWF  x90
20CC:  RCALL  1AF4
....................             break; 
20CE:  BRA    20EC
....................  
....................          case 0x22:  //set_control_line_state 
....................             usb_cdc_carrier=usb_ep0_rx_buffer[2]; 
20D0:  MOVFF  502,7F
....................             usb_put_0len_0(); 
20D4:  CLRF   x90
20D6:  RCALL  1AF4
....................             break; 
20D8:  BRA    20EC
....................  
....................          case 0x23:  //send_break 
....................             usb_cdc_break=make16(usb_ep0_rx_buffer[2],usb_ep0_rx_buffer[3]); 
20DA:  MOVFF  502,31
20DE:  MOVFF  503,30
....................             usb_put_0len_0(); 
20E2:  CLRF   x90
20E4:  RCALL  1AF4
....................             break; 
20E6:  BRA    20EC
....................  
....................          default: 
....................             usb_request_stall(); 
20E8:  RCALL  1AFA
....................             break; 
20EA:  BRA    20EC
20EC:  MOVLB  5
....................       } 
....................    } 
.................... } 
20EE:  MOVLB  0
20F0:  GOTO   211A (RETURN)
....................  
.................... //handle OUT token done interrupt on endpoint 3 [buffer incoming received chars] 
.................... void usb_isr_tok_out_cdc_data_dne(void) { 
....................    usb_cdc_get_buffer_status.got=TRUE; 
*
2366:  BSF    x7C.0
....................    usb_cdc_get_buffer_status.index=0; 
2368:  CLRF   x7E
.................... #if (defined(__PIC__)) 
....................    #if __PIC__ 
....................     usb_cdc_get_buffer_status.len=usb_rx_packet_size(USB_CDC_DATA_OUT_ENDPOINT); 
236A:  MOVLW  02
236C:  MOVWF  x8E
236E:  BRA    233E
2370:  MOVFF  01,7D
....................    #else 
....................     usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................        USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
....................    #endif 
.................... #else 
....................    usb_cdc_get_buffer_status.len=usb_get_packet_buffer( 
....................       USB_CDC_DATA_OUT_ENDPOINT,&usb_cdc_get_buffer_status_buffer[0],USB_CDC_DATA_OUT_SIZE); 
.................... #endif 
.................... } 
2374:  GOTO   2388 (RETURN)
....................  
.................... //handle IN token done interrupt on endpoint 2 [transmit buffered characters] 
.................... void usb_isr_tok_in_cdc_data_dne(void) { 
....................    if (usb_cdc_put_buffer_nextin) { 
*
2498:  MOVF   x7B,F
249A:  BZ    24A0
....................       usb_cdc_flush_out_buffer(); 
249C:  BRA    2476
....................    } 
....................    //send a 0len packet if needed 
.................... //   else if (usb_cdc_last_data_packet_size==USB_CDC_DATA_IN_SIZE) { 
.................... //      usb_cdc_last_data_packet_size=0; 
.................... //      printf(putc_tbe, "FL 0\r\n"); 
.................... //      usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,0,0,USB_DTS_TOGGLE); 
.................... //   } 
....................    else { 
249E:  BRA    24A2
....................       usb_cdc_put_buffer_free=TRUE; 
24A0:  BSF    x7A.0
....................       //printf(putc_tbe, "FL DONE\r\n"); 
....................    } 
.................... } 
24A2:  GOTO   24C6 (RETURN)
....................  
.................... void usb_cdc_flush_out_buffer(void) { 
....................    if (usb_cdc_put_buffer_nextin) { 
*
2476:  MOVF   x7B,F
2478:  BZ    2494
....................       usb_cdc_put_buffer_free=FALSE; 
247A:  BCF    x7A.0
....................       //usb_cdc_last_data_packet_size=usb_cdc_put_buffer_nextin; 
....................       //printf(putc_tbe, "FL %U\r\n", usb_cdc_put_buffer_nextin); 
....................       usb_put_packet(USB_CDC_DATA_IN_ENDPOINT,usb_cdc_put_buffer,usb_cdc_put_buffer_nextin,USB_DTS_TOGGLE); 
247C:  MOVLW  02
247E:  MOVWF  x8E
2480:  CLRF   x90
2482:  MOVLW  3A
2484:  MOVWF  x8F
2486:  CLRF   x92
2488:  MOVFF  7B,91
248C:  MOVLW  02
248E:  MOVWF  x93
2490:  BRA    23CE
....................       usb_cdc_put_buffer_nextin=0; 
2492:  CLRF   x7B
....................    } 
.................... } 
2494:  GOTO   249E (RETURN)
....................  
.................... void usb_cdc_init(void) { 
....................    usb_cdc_line_coding.dwDTERrate=9600; 
*
1A12:  CLRF   2C
1A14:  CLRF   2B
1A16:  MOVLW  25
1A18:  MOVWF  2A
1A1A:  MOVLW  80
1A1C:  MOVWF  29
....................    usb_cdc_line_coding.bCharFormat=0; 
1A1E:  CLRF   2D
....................    usb_cdc_line_coding.bParityType=0; 
1A20:  CLRF   2E
....................    usb_cdc_line_coding.bDataBits=8; 
1A22:  MOVLW  08
1A24:  MOVWF  2F
....................    (int8)usb_cdc_carrier=0; 
1A26:  CLRF   x7F
....................    usb_cdc_got_set_line_coding=FALSE; 
1A28:  BCF    x7A.1
....................    usb_cdc_break=0; 
1A2A:  CLRF   31
1A2C:  CLRF   30
....................    usb_cdc_put_buffer_nextin=0; 
1A2E:  CLRF   x7B
....................    usb_cdc_get_buffer_status.got=0; 
1A30:  BCF    x7C.0
....................    usb_cdc_put_buffer_free=TRUE; 
1A32:  BSF    x7A.0
.................... } 
1A34:  GOTO   1A56 (RETURN)
....................  
.................... ////////////////// END USB CONTROL HANDLING ////////////////////////////////// 
....................  
.................... ////////////////// BEGIN USB<->RS232 CDC LIBRARY ///////////////////////////// 
....................  
.................... char usb_cdc_getc(void) { 
....................    char c; 
....................  
....................    while (!usb_cdc_kbhit()) {} 
....................  
....................    c=usb_cdc_get_buffer_status_buffer[usb_cdc_get_buffer_status.index++]; 
....................    if (usb_cdc_get_buffer_status.index >= usb_cdc_get_buffer_status.len) { 
....................       usb_cdc_get_buffer_status.got=FALSE; 
....................       usb_flush_out(USB_CDC_DATA_OUT_ENDPOINT, USB_DTS_TOGGLE); 
....................    } 
....................  
....................    return(c); 
.................... } 
....................  
.................... void usb_cdc_putc_fast(char c) { 
....................    int1 old_gie; 
....................  
....................    //disable global interrupts 
....................    old_gie=INT_GIE; 
....................    INT_GIE=0; 
....................  
....................    if (usb_cdc_put_buffer_nextin >= USB_CDC_DATA_IN_SIZE) { 
....................       usb_cdc_put_buffer_nextin=USB_CDC_DATA_IN_SIZE-1;  //we just overflowed the buffer! 
....................    } 
....................    usb_cdc_put_buffer[usb_cdc_put_buffer_nextin++]=c; 
....................  
....................    //renable global interrupts 
....................    INT_GIE=old_gie; 
....................  
....................    /* 
....................    if (usb_tbe(USB_CDC_DATA_IN_ENDPOINT)) { 
....................       if (usb_cdc_put_buffer_nextin) 
....................          usb_cdc_flush_out_buffer(); 
....................    } 
....................    */ 
....................    if (usb_cdc_put_buffer_free) { 
....................       usb_cdc_flush_out_buffer(); 
....................    } 
.................... } 
....................  
.................... void usb_cdc_putc(char c) { 
....................    while (!usb_cdc_putready()) { 
....................       if (usb_cdc_put_buffer_free) { 
....................          usb_cdc_flush_out_buffer(); 
....................       } 
....................       //delay_ms(500); 
....................       //printf(putc_tbe,"TBE=%U CNT=%U LST=%U\r\n",usb_tbe(USB_CDC_DATA_IN_ENDPOINT), usb_cdc_put_buffer_nextin, usb_cdc_last_data_packet_size); 
....................    } 
....................    usb_cdc_putc_fast(c); 
.................... } 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... BYTE gethex1_usb() { 
....................    char digit; 
....................  
....................    digit = usb_cdc_getc(); 
....................  
....................    usb_cdc_putc(digit); 
....................  
....................    if(digit<='9') 
....................      return(digit-'0'); 
....................    else 
....................      return((toupper(digit)-'A')+10); 
.................... } 
....................  
.................... BYTE gethex_usb() { 
....................    int lo,hi; 
....................  
....................    hi = gethex1_usb(); 
....................    lo = gethex1_usb(); 
....................    if(lo==0xdd) 
....................      return(hi); 
....................    else 
....................      return( hi*16+lo ); 
.................... } 
....................  
.................... void get_string_usb(char* s, int max) { 
....................    int len; 
....................    char c; 
....................  
....................    --max; 
....................    len=0; 
....................    do { 
....................      c=usb_cdc_getc(); 
....................      if(c==8) {  // Backspace 
....................         if(len>0) { 
....................           len--; 
....................           usb_cdc_putc(c); 
....................           usb_cdc_putc(' '); 
....................           usb_cdc_putc(c); 
....................         } 
....................      } else if ((c>=' ')&&(c<='~')) 
....................        if(len<max) { 
....................          s[len++]=c; 
....................          usb_cdc_putc(c); 
....................        } 
....................    } while(c!=13); 
....................    s[len]=0; 
.................... } 
....................  
....................  
.................... // stdlib.h is required for the ato_ conversions 
.................... // in the following functions 
.................... #ifdef _STDLIB 
....................  
.................... signed int get_int_usb() { 
....................   char s[5]; 
....................   signed int i; 
....................  
....................   get_string_usb(s, 5); 
....................  
....................   i=atoi(s); 
....................   return(i); 
.................... } 
....................  
.................... signed long get_long_usb() { 
....................   char s[7]; 
....................   signed long l; 
....................  
....................   get_string_usb(s, 7); 
....................   l=atol(s); 
....................   return(l); 
.................... } 
....................  
.................... float get_float_usb() { 
....................   char s[20]; 
....................   float f; 
....................  
....................   get_string_usb(s, 20); 
....................   f = atof(s); 
....................   return(f); 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float32 atof(char * s); 
....................  
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float48 atof48(char * s); 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... float64 atof64(char * s); 
.................... #endif 
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... float32 atoe(char * s); 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: float32 strtod(char * s,char *endptr) 
....................  * converts the initial portion of the string s to a float32 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standart template: float32 strto(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr); 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #endif 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8 *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8 *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... float32 atof(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... float48 atof48(char * s) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................  #cdebug5      
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10;  
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... float64 atof64(char * s) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if !defined(__PCD__) 
.................... float32 strtod(char *s,char *endptr) { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 strtof(char *s,char *endptr) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float48 strtof48(char *s,char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s,char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    unsigned int8 sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c=s[ptr++]; 
....................  
....................  
....................    while((c>='0' && c<='9') || c=='+' || c=='-' || c=='.') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 0) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          point = 1; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       while((c >= '0' && c <= '9') && point == 1) { 
....................          pow10 = pow10*10; 
....................          result += (c - '0')/pow10; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '+') { 
....................          c = s[ptr++]; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    BYTE t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=TRUE; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = FALSE; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
....................                                               
....................  
.................... #use fast_io (a) 
.................... #use fast_io (b) 
.................... #use fast_io (c) 
....................  
....................  
.................... int8 a,b,c,d=0; 
....................  
....................  
....................  
.................... void main() 
.................... { 
*
2624:  CLRF   FF8
2626:  BCF    FD0.7
2628:  BSF    0D.7
262A:  CLRF   FEA
262C:  CLRF   FE9
262E:  MOVF   FC1,W
2630:  ANDLW  C0
2632:  IORLW  0F
2634:  MOVWF  FC1
2636:  MOVLW  07
2638:  MOVWF  FB4
263A:  CLRF   1E
263C:  CLRF   20
263E:  MOVLW  04
2640:  MOVWF  21
2642:  MOVLW  0C
2644:  MOVWF  22
2646:  CLRF   26
2648:  CLRF   x7B
264A:  CLRF   x80
264C:  CLRF   x81
264E:  CLRF   x82
2650:  CLRF   x8A
....................       set_tris_a(0b00000000); 
2652:  MOVLW  00
2654:  MOVWF  F92
....................       set_tris_b(0b11111111); 
2656:  MOVLW  FF
2658:  MOVWF  F93
....................       set_tris_c(0b01000000); 
265A:  MOVLW  40
265C:  MOVWF  F94
....................       setup_adc_ports(AN0_TO_AN1|VSS_VDD); 
265E:  MOVF   FC1,W
2660:  ANDLW  C0
2662:  IORLW  0D
2664:  MOVWF  FC1
....................       setup_adc(ADC_CLOCK_INTERNAL); 
2666:  BSF    FC0.0
2668:  BSF    FC0.1
266A:  BSF    FC0.2
266C:  BCF    FC0.7
266E:  BSF    FC2.0
....................       setup_spi (SPI_SS_DISABLED) ; 
2670:  BCF    FC6.5
2672:  MOVLW  01
2674:  MOVWF  FC6
2676:  MOVLW  00
2678:  MOVWF  FC7
....................       setup_wdt (WDT_OFF) ; 
267A:  BCF    FD1.0
....................       setup_timer_0(RTCC_INTERNAL|RTCC_DIV_2); 
267C:  MOVLW  80
267E:  MOVWF  FD5
....................       setup_timer_1 (T1_DISABLED) ; 
2680:  CLRF   FCD
....................       setup_timer_2(T2_DIV_BY_16,239,1); 
2682:  MOVLW  00
2684:  IORLW  06
2686:  MOVWF  FCA
2688:  MOVLW  EF
268A:  MOVWF  FCB
....................       setup_timer_3 (T3_DISABLED|T3_DIV_BY_1) ; 
268C:  MOVF   FB1,W
268E:  ANDLW  48
2690:  MOVWF  FB1
....................       setup_comparator (NC_NC_NC_NC) ; 
2692:  MOVLW  07
2694:  MOVWF  FB4
2696:  MOVF   F92,W
2698:  MOVLW  27
269A:  MOVWF  00
269C:  DECFSZ 00,F
269E:  BRA    269C
26A0:  BRA    26A2
26A2:  MOVF   FB4,W
26A4:  BCF    FA1.6
....................       setup_vref (FALSE) ; 
26A6:  CLRF   FB5
....................       disable_interrupts(INT_TIMER0); 
26A8:  BCF    FF2.5
....................       disable_interrupts(GLOBAL); 
26AA:  BCF    FF2.6
26AC:  BCF    FF2.7
26AE:  BTFSC  FF2.7
26B0:  BRA    26AC
....................       disable_interrupts(INT_TIMER0); 
26B2:  BCF    FF2.5
....................       disable_interrupts(GLOBAL); 
26B4:  BCF    FF2.6
26B6:  BCF    FF2.7
26B8:  BTFSC  FF2.7
26BA:  BRA    26B6
....................  
.................... output_a(0x00); 
26BC:  CLRF   F89
....................          //input(pin_b5) 
....................          //output_a(0b00001010); 
....................          //delay_ms(2); 
....................   while(1)        
.................... { 
.................... output_a(0b00000000); 
26BE:  CLRF   F89
....................        
....................       //Cisim 
....................       while ( !input(pin_c6) && (!input(pin_b4) || !input(pin_b3))) 
....................       { 
26C0:  BTFSC  F82.6
26C2:  BRA    26EC
26C4:  BTFSS  F81.4
26C6:  BRA    26CC
26C8:  BTFSC  F81.3
26CA:  BRA    26EC
....................          output_a(0b00000110); 
26CC:  MOVLW  06
26CE:  MOVWF  F89
....................          delay_ms(180); 
26D0:  MOVLW  B4
26D2:  MOVWF  x8B
26D4:  RCALL  25FC
....................          output_a(0b00001010); 
26D6:  MOVLW  0A
26D8:  MOVWF  F89
....................          delay_ms(150); 
26DA:  MOVLW  96
26DC:  MOVWF  x8B
26DE:  RCALL  25FC
....................          a=0; 
26E0:  CLRF   x87
....................          b=0; 
26E2:  CLRF   x88
....................          c=0; 
26E4:  CLRF   x89
....................          d=1; 
26E6:  MOVLW  01
26E8:  MOVWF  x8A
....................       } 
26EA:  BRA    26C0
....................        
....................       //Düz gitme 
....................       while(input(pin_b7) && input(pin_b6) && input(pin_b5) && !input(pin_b4) && !input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................       { 
26EC:  BTFSS  F81.7
26EE:  BRA    271C
26F0:  BTFSS  F81.6
26F2:  BRA    271C
26F4:  BTFSS  F81.5
26F6:  BRA    271C
26F8:  BTFSC  F81.4
26FA:  BRA    271C
26FC:  BTFSC  F81.3
26FE:  BRA    271C
2700:  BTFSS  F81.2
2702:  BRA    271C
2704:  BTFSS  F81.1
2706:  BRA    271C
2708:  BTFSS  F81.0
270A:  BRA    271C
....................             output_a(0b00001010); 
270C:  MOVLW  0A
270E:  MOVWF  F89
....................             a=0; 
2710:  CLRF   x87
....................             b=0; 
2712:  CLRF   x88
....................             c=1; 
2714:  MOVLW  01
2716:  MOVWF  x89
....................             d=0; 
2718:  CLRF   x8A
....................       } 
271A:  BRA    26EC
....................       while(input(pin_b7) && input(pin_b6) && input(pin_b5) && !input(pin_b4) && !input(pin_b3) && !input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................       { 
271C:  BTFSS  F81.7
271E:  BRA    274C
2720:  BTFSS  F81.6
2722:  BRA    274C
2724:  BTFSS  F81.5
2726:  BRA    274C
2728:  BTFSC  F81.4
272A:  BRA    274C
272C:  BTFSC  F81.3
272E:  BRA    274C
2730:  BTFSC  F81.2
2732:  BRA    274C
2734:  BTFSS  F81.1
2736:  BRA    274C
2738:  BTFSS  F81.0
273A:  BRA    274C
....................             output_a(0b00001010); 
273C:  MOVLW  0A
273E:  MOVWF  F89
....................             a=0; 
2740:  CLRF   x87
....................             b=0; 
2742:  CLRF   x88
....................             c=1; 
2744:  MOVLW  01
2746:  MOVWF  x89
....................             d=0; 
2748:  CLRF   x8A
....................       } 
274A:  BRA    271C
....................       while(input(pin_b7) && input(pin_b6) && !input(pin_b5) && !input(pin_b4) && !input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................       { 
274C:  BTFSS  F81.7
274E:  BRA    277C
2750:  BTFSS  F81.6
2752:  BRA    277C
2754:  BTFSC  F81.5
2756:  BRA    277C
2758:  BTFSC  F81.4
275A:  BRA    277C
275C:  BTFSC  F81.3
275E:  BRA    277C
2760:  BTFSS  F81.2
2762:  BRA    277C
2764:  BTFSS  F81.1
2766:  BRA    277C
2768:  BTFSS  F81.0
276A:  BRA    277C
....................             output_a(0b00001010); 
276C:  MOVLW  0A
276E:  MOVWF  F89
....................             a=0; 
2770:  CLRF   x87
....................             b=0; 
2772:  CLRF   x88
....................             c=1; 
2774:  MOVLW  01
2776:  MOVWF  x89
....................             d=0; 
2778:  CLRF   x8A
....................       } 
277A:  BRA    274C
....................       while(input(pin_b7) && input(pin_b6) && !input(pin_b5) && !input(pin_b4) && !input(pin_b3) && !input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................       { 
277C:  BTFSS  F81.7
277E:  BRA    27AC
2780:  BTFSS  F81.6
2782:  BRA    27AC
2784:  BTFSC  F81.5
2786:  BRA    27AC
2788:  BTFSC  F81.4
278A:  BRA    27AC
278C:  BTFSC  F81.3
278E:  BRA    27AC
2790:  BTFSC  F81.2
2792:  BRA    27AC
2794:  BTFSS  F81.1
2796:  BRA    27AC
2798:  BTFSS  F81.0
279A:  BRA    27AC
....................             output_a(0b00001010); 
279C:  MOVLW  0A
279E:  MOVWF  F89
....................             a=0; 
27A0:  CLRF   x87
....................             b=0; 
27A2:  CLRF   x88
....................             c=1; 
27A4:  MOVLW  01
27A6:  MOVWF  x89
....................             d=0; 
27A8:  CLRF   x8A
....................       } 
27AA:  BRA    277C
....................        
....................       //Sað Dönüþ 
....................            
....................         while(input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && !input(pin_b3) && !input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
27AC:  BTFSS  F81.7
27AE:  BRA    27EC
27B0:  BTFSS  F81.6
27B2:  BRA    27EC
27B4:  BTFSS  F81.5
27B6:  BRA    27EC
27B8:  BTFSS  F81.4
27BA:  BRA    27EC
27BC:  BTFSC  F81.3
27BE:  BRA    27EC
27C0:  BTFSC  F81.2
27C2:  BRA    27EC
27C4:  BTFSS  F81.1
27C6:  BRA    27EC
27C8:  BTFSS  F81.0
27CA:  BRA    27EC
....................             output_a(0b00001000); 
27CC:  MOVLW  08
27CE:  MOVWF  F89
....................             delay_ms(1); 
27D0:  MOVLW  01
27D2:  MOVWF  x8B
27D4:  RCALL  25FC
....................             output_a(0b00001010); 
27D6:  MOVLW  0A
27D8:  MOVWF  F89
....................             delay_ms(4); 
27DA:  MOVLW  04
27DC:  MOVWF  x8B
27DE:  RCALL  25FC
....................             a=0; 
27E0:  CLRF   x87
....................             b=0; 
27E2:  CLRF   x88
....................             c=1; 
27E4:  MOVLW  01
27E6:  MOVWF  x89
....................             d=0; 
27E8:  CLRF   x8A
....................         } 
27EA:  BRA    27AC
....................         while(input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && !input(pin_b3) && !input(pin_b2) && !input(pin_b1) && input(pin_b0)) 
....................         { 
27EC:  BTFSS  F81.7
27EE:  BRA    282C
27F0:  BTFSS  F81.6
27F2:  BRA    282C
27F4:  BTFSS  F81.5
27F6:  BRA    282C
27F8:  BTFSS  F81.4
27FA:  BRA    282C
27FC:  BTFSC  F81.3
27FE:  BRA    282C
2800:  BTFSC  F81.2
2802:  BRA    282C
2804:  BTFSC  F81.1
2806:  BRA    282C
2808:  BTFSS  F81.0
280A:  BRA    282C
....................             output_a(0b00001000); 
280C:  MOVLW  08
280E:  MOVWF  F89
....................             delay_ms(2); 
2810:  MOVLW  02
2812:  MOVWF  x8B
2814:  RCALL  25FC
....................             output_a(0b00001010); 
2816:  MOVLW  0A
2818:  MOVWF  F89
....................             delay_ms(3); 
281A:  MOVLW  03
281C:  MOVWF  x8B
281E:  RCALL  25FC
....................             a=1; 
2820:  MOVLW  01
2822:  MOVWF  x87
....................             b=0; 
2824:  CLRF   x88
....................             c=0; 
2826:  CLRF   x89
....................             d=0; 
2828:  CLRF   x8A
....................         } 
282A:  BRA    27EC
....................         while(input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && !input(pin_b2) && !input(pin_b1) && input(pin_b0)) 
....................         { 
282C:  BTFSS  F81.7
282E:  BRA    286C
2830:  BTFSS  F81.6
2832:  BRA    286C
2834:  BTFSS  F81.5
2836:  BRA    286C
2838:  BTFSS  F81.4
283A:  BRA    286C
283C:  BTFSS  F81.3
283E:  BRA    286C
2840:  BTFSC  F81.2
2842:  BRA    286C
2844:  BTFSC  F81.1
2846:  BRA    286C
2848:  BTFSS  F81.0
284A:  BRA    286C
....................             output_a(0b00001000); 
284C:  MOVLW  08
284E:  MOVWF  F89
....................             delay_ms(1); 
2850:  MOVLW  01
2852:  MOVWF  x8B
2854:  RCALL  25FC
....................             output_a(0b00001010); 
2856:  MOVLW  0A
2858:  MOVWF  F89
....................             delay_ms(2); 
285A:  MOVLW  02
285C:  MOVWF  x8B
285E:  RCALL  25FC
....................             a=1; 
2860:  MOVLW  01
2862:  MOVWF  x87
....................             b=0; 
2864:  CLRF   x88
....................             c=0; 
2866:  CLRF   x89
....................             d=0; 
2868:  CLRF   x8A
....................         }  
286A:  BRA    282C
....................         while(input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && !input(pin_b2) && !input(pin_b1) && !input(pin_b0)) 
....................         { 
286C:  BTFSS  F81.7
286E:  BRA    28AC
2870:  BTFSS  F81.6
2872:  BRA    28AC
2874:  BTFSS  F81.5
2876:  BRA    28AC
2878:  BTFSS  F81.4
287A:  BRA    28AC
287C:  BTFSS  F81.3
287E:  BRA    28AC
2880:  BTFSC  F81.2
2882:  BRA    28AC
2884:  BTFSC  F81.1
2886:  BRA    28AC
2888:  BTFSC  F81.0
288A:  BRA    28AC
....................             output_a(0b00001000); 
288C:  MOVLW  08
288E:  MOVWF  F89
....................             delay_ms(2); 
2890:  MOVLW  02
2892:  MOVWF  x8B
2894:  RCALL  25FC
....................             output_a(0b00001010); 
2896:  MOVLW  0A
2898:  MOVWF  F89
....................             delay_ms(3); 
289A:  MOVLW  03
289C:  MOVWF  x8B
289E:  RCALL  25FC
....................             a=1; 
28A0:  MOVLW  01
28A2:  MOVWF  x87
....................             b=0; 
28A4:  CLRF   x88
....................             c=0; 
28A6:  CLRF   x89
....................             d=0; 
28A8:  CLRF   x8A
....................         } 
28AA:  BRA    286C
....................         while(input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && !input(pin_b1) && !input(pin_b0)) 
....................         { 
28AC:  BTFSS  F81.7
28AE:  BRA    28EC
28B0:  BTFSS  F81.6
28B2:  BRA    28EC
28B4:  BTFSS  F81.5
28B6:  BRA    28EC
28B8:  BTFSS  F81.4
28BA:  BRA    28EC
28BC:  BTFSS  F81.3
28BE:  BRA    28EC
28C0:  BTFSS  F81.2
28C2:  BRA    28EC
28C4:  BTFSC  F81.1
28C6:  BRA    28EC
28C8:  BTFSC  F81.0
28CA:  BRA    28EC
....................             output_a(0b00001000); 
28CC:  MOVLW  08
28CE:  MOVWF  F89
....................             delay_ms(2); 
28D0:  MOVLW  02
28D2:  MOVWF  x8B
28D4:  RCALL  25FC
....................             output_a(0b00001001); 
28D6:  MOVLW  09
28D8:  MOVWF  F89
....................             delay_ms(1); 
28DA:  MOVLW  01
28DC:  MOVWF  x8B
28DE:  RCALL  25FC
....................             a=1; 
28E0:  MOVLW  01
28E2:  MOVWF  x87
....................             b=0; 
28E4:  CLRF   x88
....................             c=0; 
28E6:  CLRF   x89
....................             d=0; 
28E8:  CLRF   x8A
....................         } 
28EA:  BRA    28AC
....................         while(input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && !input(pin_b0)) 
....................         { 
28EC:  BTFSS  F81.7
28EE:  BRA    292C
28F0:  BTFSS  F81.6
28F2:  BRA    292C
28F4:  BTFSS  F81.5
28F6:  BRA    292C
28F8:  BTFSS  F81.4
28FA:  BRA    292C
28FC:  BTFSS  F81.3
28FE:  BRA    292C
2900:  BTFSS  F81.2
2902:  BRA    292C
2904:  BTFSS  F81.1
2906:  BRA    292C
2908:  BTFSC  F81.0
290A:  BRA    292C
....................             output_a(0b00001000); 
290C:  MOVLW  08
290E:  MOVWF  F89
....................             delay_ms(3); 
2910:  MOVLW  03
2912:  MOVWF  x8B
2914:  RCALL  25FC
....................             output_a(0b00001001); 
2916:  MOVLW  09
2918:  MOVWF  F89
....................             delay_ms(1); 
291A:  MOVLW  01
291C:  MOVWF  x8B
291E:  RCALL  25FC
....................             a=1; 
2920:  MOVLW  01
2922:  MOVWF  x87
....................             b=0; 
2924:  CLRF   x88
....................             c=0; 
2926:  CLRF   x89
....................             d=0; 
2928:  CLRF   x8A
....................         } 
292A:  BRA    28EC
....................         while(input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && !input(pin_b3) && !input(pin_b2) && !input(pin_b1) && !input(pin_b0)) 
....................         { 
292C:  BTFSS  F81.7
292E:  BRA    296C
2930:  BTFSS  F81.6
2932:  BRA    296C
2934:  BTFSS  F81.5
2936:  BRA    296C
2938:  BTFSS  F81.4
293A:  BRA    296C
293C:  BTFSC  F81.3
293E:  BRA    296C
2940:  BTFSC  F81.2
2942:  BRA    296C
2944:  BTFSC  F81.1
2946:  BRA    296C
2948:  BTFSC  F81.0
294A:  BRA    296C
....................             output_a(0b00001000); 
294C:  MOVLW  08
294E:  MOVWF  F89
....................             delay_ms(3); 
2950:  MOVLW  03
2952:  MOVWF  x8B
2954:  RCALL  25FC
....................             output_a(0b00001001); 
2956:  MOVLW  09
2958:  MOVWF  F89
....................             delay_ms(1); 
295A:  MOVLW  01
295C:  MOVWF  x8B
295E:  RCALL  25FC
....................             a=1; 
2960:  MOVLW  01
2962:  MOVWF  x87
....................             b=0; 
2964:  CLRF   x88
....................             c=0; 
2966:  CLRF   x89
....................             d=0; 
2968:  CLRF   x8A
....................         } 
296A:  BRA    292C
....................          
....................         while(input(pin_b7) && input(pin_b6) && input(pin_b5) && !input(pin_b4) && !input(pin_b3) && !input(pin_b2) && !input(pin_b1) && !input(pin_b0)) 
....................         { 
296C:  BTFSS  F81.7
296E:  BRA    29AC
2970:  BTFSS  F81.6
2972:  BRA    29AC
2974:  BTFSS  F81.5
2976:  BRA    29AC
2978:  BTFSC  F81.4
297A:  BRA    29AC
297C:  BTFSC  F81.3
297E:  BRA    29AC
2980:  BTFSC  F81.2
2982:  BRA    29AC
2984:  BTFSC  F81.1
2986:  BRA    29AC
2988:  BTFSC  F81.0
298A:  BRA    29AC
....................             output_a(0b00001000); 
298C:  MOVLW  08
298E:  MOVWF  F89
....................             delay_ms(3); 
2990:  MOVLW  03
2992:  MOVWF  x8B
2994:  RCALL  25FC
....................             output_a(0b00001001); 
2996:  MOVLW  09
2998:  MOVWF  F89
....................             delay_ms(1); 
299A:  MOVLW  01
299C:  MOVWF  x8B
299E:  RCALL  25FC
....................             a=1; 
29A0:  MOVLW  01
29A2:  MOVWF  x87
....................             b=0; 
29A4:  CLRF   x88
....................             c=0; 
29A6:  CLRF   x89
....................             d=0; 
29A8:  CLRF   x8A
....................         } 
29AA:  BRA    296C
....................         while(input(pin_b7) && input(pin_b6) && input(pin_b5) && !input(pin_b4) && !input(pin_b3) && !input(pin_b2) && !input(pin_b1) && input(pin_b0)) 
....................         { 
29AC:  BTFSS  F81.7
29AE:  BRA    29EC
29B0:  BTFSS  F81.6
29B2:  BRA    29EC
29B4:  BTFSS  F81.5
29B6:  BRA    29EC
29B8:  BTFSC  F81.4
29BA:  BRA    29EC
29BC:  BTFSC  F81.3
29BE:  BRA    29EC
29C0:  BTFSC  F81.2
29C2:  BRA    29EC
29C4:  BTFSC  F81.1
29C6:  BRA    29EC
29C8:  BTFSS  F81.0
29CA:  BRA    29EC
....................             output_a(0b00001000); 
29CC:  MOVLW  08
29CE:  MOVWF  F89
....................             delay_ms(3); 
29D0:  MOVLW  03
29D2:  MOVWF  x8B
29D4:  RCALL  25FC
....................             output_a(0b00001001); 
29D6:  MOVLW  09
29D8:  MOVWF  F89
....................             delay_ms(1); 
29DA:  MOVLW  01
29DC:  MOVWF  x8B
29DE:  RCALL  25FC
....................             a=1; 
29E0:  MOVLW  01
29E2:  MOVWF  x87
....................             b=0; 
29E4:  CLRF   x88
....................             c=0; 
29E6:  CLRF   x89
....................             d=0; 
29E8:  CLRF   x8A
....................         } 
29EA:  BRA    29AC
....................         while(input(pin_b7) && input(pin_b6) && !input(pin_b5) && !input(pin_b4) && !input(pin_b3) && !input(pin_b2) && !input(pin_b1) && !input(pin_b0)) 
....................         { 
29EC:  BTFSS  F81.7
29EE:  BRA    2A2C
29F0:  BTFSS  F81.6
29F2:  BRA    2A2C
29F4:  BTFSC  F81.5
29F6:  BRA    2A2C
29F8:  BTFSC  F81.4
29FA:  BRA    2A2C
29FC:  BTFSC  F81.3
29FE:  BRA    2A2C
2A00:  BTFSC  F81.2
2A02:  BRA    2A2C
2A04:  BTFSC  F81.1
2A06:  BRA    2A2C
2A08:  BTFSC  F81.0
2A0A:  BRA    2A2C
....................             output_a(0b00001000); 
2A0C:  MOVLW  08
2A0E:  MOVWF  F89
....................             delay_ms(4); 
2A10:  MOVLW  04
2A12:  MOVWF  x8B
2A14:  RCALL  25FC
....................             output_a(0b00001001); 
2A16:  MOVLW  09
2A18:  MOVWF  F89
....................             delay_ms(1); 
2A1A:  MOVLW  01
2A1C:  MOVWF  x8B
2A1E:  RCALL  25FC
....................             a=1; 
2A20:  MOVLW  01
2A22:  MOVWF  x87
....................             b=0; 
2A24:  CLRF   x88
....................             c=0; 
2A26:  CLRF   x89
....................             d=0; 
2A28:  CLRF   x8A
....................         } 
2A2A:  BRA    29EC
....................         while(input(pin_b7) && !input(pin_b6) && !input(pin_b5) && !input(pin_b4) && !input(pin_b3) && !input(pin_b2) && !input(pin_b1) && !input(pin_b0)) 
....................         { 
2A2C:  BTFSS  F81.7
2A2E:  BRA    2A6C
2A30:  BTFSC  F81.6
2A32:  BRA    2A6C
2A34:  BTFSC  F81.5
2A36:  BRA    2A6C
2A38:  BTFSC  F81.4
2A3A:  BRA    2A6C
2A3C:  BTFSC  F81.3
2A3E:  BRA    2A6C
2A40:  BTFSC  F81.2
2A42:  BRA    2A6C
2A44:  BTFSC  F81.1
2A46:  BRA    2A6C
2A48:  BTFSC  F81.0
2A4A:  BRA    2A6C
....................             output_a(0b00001000); 
2A4C:  MOVLW  08
2A4E:  MOVWF  F89
....................             delay_ms(4); 
2A50:  MOVLW  04
2A52:  MOVWF  x8B
2A54:  RCALL  25FC
....................             output_a(0b00001001); 
2A56:  MOVLW  09
2A58:  MOVWF  F89
....................             delay_ms(1); 
2A5A:  MOVLW  01
2A5C:  MOVWF  x8B
2A5E:  RCALL  25FC
....................             a=1; 
2A60:  MOVLW  01
2A62:  MOVWF  x87
....................             b=0; 
2A64:  CLRF   x88
....................             c=0; 
2A66:  CLRF   x89
....................             d=0; 
2A68:  CLRF   x8A
....................         } 
2A6A:  BRA    2A2C
....................         // Sol Dönüþ 
....................         while(input(pin_b7) && input(pin_b6) && !input(pin_b5) && !input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2A6C:  BTFSS  F81.7
2A6E:  BRA    2AAC
2A70:  BTFSS  F81.6
2A72:  BRA    2AAC
2A74:  BTFSC  F81.5
2A76:  BRA    2AAC
2A78:  BTFSC  F81.4
2A7A:  BRA    2AAC
2A7C:  BTFSS  F81.3
2A7E:  BRA    2AAC
2A80:  BTFSS  F81.2
2A82:  BRA    2AAC
2A84:  BTFSS  F81.1
2A86:  BRA    2AAC
2A88:  BTFSS  F81.0
2A8A:  BRA    2AAC
....................             output_a(0b00000010); 
2A8C:  MOVLW  02
2A8E:  MOVWF  F89
....................             delay_ms(1); 
2A90:  MOVLW  01
2A92:  MOVWF  x8B
2A94:  RCALL  25FC
....................             output_a(0b00001010); 
2A96:  MOVLW  0A
2A98:  MOVWF  F89
....................             delay_ms(4); 
2A9A:  MOVLW  04
2A9C:  MOVWF  x8B
2A9E:  RCALL  25FC
....................             a=0; 
2AA0:  CLRF   x87
....................             b=0; 
2AA2:  CLRF   x88
....................             c=1; 
2AA4:  MOVLW  01
2AA6:  MOVWF  x89
....................             d=0; 
2AA8:  CLRF   x8A
....................         }  
2AAA:  BRA    2A6C
....................         while(input(pin_b7) && !input(pin_b6) && !input(pin_b5) && !input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2AAC:  BTFSS  F81.7
2AAE:  BRA    2AEA
2AB0:  BTFSC  F81.6
2AB2:  BRA    2AEA
2AB4:  BTFSC  F81.5
2AB6:  BRA    2AEA
2AB8:  BTFSC  F81.4
2ABA:  BRA    2AEA
2ABC:  BTFSS  F81.3
2ABE:  BRA    2AEA
2AC0:  BTFSS  F81.2
2AC2:  BRA    2AEA
2AC4:  BTFSS  F81.1
2AC6:  BRA    2AEA
2AC8:  BTFSS  F81.0
2ACA:  BRA    2AEA
....................             output_a(0b00000010); 
2ACC:  MOVLW  02
2ACE:  MOVWF  F89
....................             delay_ms(2); 
2AD0:  MOVWF  x8B
2AD2:  RCALL  25FC
....................             output_a(0b00001010); 
2AD4:  MOVLW  0A
2AD6:  MOVWF  F89
....................             delay_ms(3); 
2AD8:  MOVLW  03
2ADA:  MOVWF  x8B
2ADC:  RCALL  25FC
....................             a=0; 
2ADE:  CLRF   x87
....................             b=1; 
2AE0:  MOVLW  01
2AE2:  MOVWF  x88
....................             c=0; 
2AE4:  CLRF   x89
....................             d=0; 
2AE6:  CLRF   x8A
....................         } 
2AE8:  BRA    2AAC
....................         while(input(pin_b7) && !input(pin_b6) && !input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2AEA:  BTFSS  F81.7
2AEC:  BRA    2B2A
2AEE:  BTFSC  F81.6
2AF0:  BRA    2B2A
2AF2:  BTFSC  F81.5
2AF4:  BRA    2B2A
2AF6:  BTFSS  F81.4
2AF8:  BRA    2B2A
2AFA:  BTFSS  F81.3
2AFC:  BRA    2B2A
2AFE:  BTFSS  F81.2
2B00:  BRA    2B2A
2B02:  BTFSS  F81.1
2B04:  BRA    2B2A
2B06:  BTFSS  F81.0
2B08:  BRA    2B2A
....................             output_a(0b00000010); 
2B0A:  MOVLW  02
2B0C:  MOVWF  F89
....................             delay_ms(1); 
2B0E:  MOVLW  01
2B10:  MOVWF  x8B
2B12:  RCALL  25FC
....................             output_a(0b00001010); 
2B14:  MOVLW  0A
2B16:  MOVWF  F89
....................             delay_ms(2); 
2B18:  MOVLW  02
2B1A:  MOVWF  x8B
2B1C:  RCALL  25FC
....................             a=0; 
2B1E:  CLRF   x87
....................             b=1; 
2B20:  MOVLW  01
2B22:  MOVWF  x88
....................             c=0; 
2B24:  CLRF   x89
....................             d=0; 
2B26:  CLRF   x8A
....................         }  
2B28:  BRA    2AEA
....................         while(!input(pin_b7) && !input(pin_b6) && !input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2B2A:  BTFSC  F81.7
2B2C:  BRA    2B68
2B2E:  BTFSC  F81.6
2B30:  BRA    2B68
2B32:  BTFSC  F81.5
2B34:  BRA    2B68
2B36:  BTFSS  F81.4
2B38:  BRA    2B68
2B3A:  BTFSS  F81.3
2B3C:  BRA    2B68
2B3E:  BTFSS  F81.2
2B40:  BRA    2B68
2B42:  BTFSS  F81.1
2B44:  BRA    2B68
2B46:  BTFSS  F81.0
2B48:  BRA    2B68
....................             output_a(0b00000010); 
2B4A:  MOVLW  02
2B4C:  MOVWF  F89
....................             delay_ms(2); 
2B4E:  MOVWF  x8B
2B50:  RCALL  25FC
....................             output_a(0b00001010); 
2B52:  MOVLW  0A
2B54:  MOVWF  F89
....................             delay_ms(3); 
2B56:  MOVLW  03
2B58:  MOVWF  x8B
2B5A:  RCALL  25FC
....................             a=0; 
2B5C:  CLRF   x87
....................             b=1; 
2B5E:  MOVLW  01
2B60:  MOVWF  x88
....................             c=0; 
2B62:  CLRF   x89
....................             d=0; 
2B64:  CLRF   x8A
....................         } 
2B66:  BRA    2B2A
....................         while(!input(pin_b7) && !input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2B68:  BTFSC  F81.7
2B6A:  BRA    2BA6
2B6C:  BTFSC  F81.6
2B6E:  BRA    2BA6
2B70:  BTFSS  F81.5
2B72:  BRA    2BA6
2B74:  BTFSS  F81.4
2B76:  BRA    2BA6
2B78:  BTFSS  F81.3
2B7A:  BRA    2BA6
2B7C:  BTFSS  F81.2
2B7E:  BRA    2BA6
2B80:  BTFSS  F81.1
2B82:  BRA    2BA6
2B84:  BTFSS  F81.0
2B86:  BRA    2BA6
....................             output_a(0b00000010); 
2B88:  MOVLW  02
2B8A:  MOVWF  F89
....................             delay_ms(2); 
2B8C:  MOVWF  x8B
2B8E:  RCALL  25FC
....................             output_a(0b00000110); 
2B90:  MOVLW  06
2B92:  MOVWF  F89
....................             delay_ms(1); 
2B94:  MOVLW  01
2B96:  MOVWF  x8B
2B98:  RCALL  25FC
....................             a=0; 
2B9A:  CLRF   x87
....................             b=1; 
2B9C:  MOVLW  01
2B9E:  MOVWF  x88
....................             c=0; 
2BA0:  CLRF   x89
....................             d=0; 
2BA2:  CLRF   x8A
....................         } 
2BA4:  BRA    2B68
....................         while(!input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2BA6:  BTFSC  F81.7
2BA8:  BRA    2BE6
2BAA:  BTFSS  F81.6
2BAC:  BRA    2BE6
2BAE:  BTFSS  F81.5
2BB0:  BRA    2BE6
2BB2:  BTFSS  F81.4
2BB4:  BRA    2BE6
2BB6:  BTFSS  F81.3
2BB8:  BRA    2BE6
2BBA:  BTFSS  F81.2
2BBC:  BRA    2BE6
2BBE:  BTFSS  F81.1
2BC0:  BRA    2BE6
2BC2:  BTFSS  F81.0
2BC4:  BRA    2BE6
....................             output_a(0b00000010); 
2BC6:  MOVLW  02
2BC8:  MOVWF  F89
....................             delay_ms(3); 
2BCA:  MOVLW  03
2BCC:  MOVWF  x8B
2BCE:  RCALL  25FC
....................             output_a(0b00000110); 
2BD0:  MOVLW  06
2BD2:  MOVWF  F89
....................             delay_ms(1); 
2BD4:  MOVLW  01
2BD6:  MOVWF  x8B
2BD8:  RCALL  25FC
....................             a=0; 
2BDA:  CLRF   x87
....................             b=1; 
2BDC:  MOVLW  01
2BDE:  MOVWF  x88
....................             c=0; 
2BE0:  CLRF   x89
....................             d=0; 
2BE2:  CLRF   x8A
....................         } 
2BE4:  BRA    2BA6
....................         while(!input(pin_b7) && !input(pin_b6) && !input(pin_b5) && !input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2BE6:  BTFSC  F81.7
2BE8:  BRA    2C26
2BEA:  BTFSC  F81.6
2BEC:  BRA    2C26
2BEE:  BTFSC  F81.5
2BF0:  BRA    2C26
2BF2:  BTFSC  F81.4
2BF4:  BRA    2C26
2BF6:  BTFSS  F81.3
2BF8:  BRA    2C26
2BFA:  BTFSS  F81.2
2BFC:  BRA    2C26
2BFE:  BTFSS  F81.1
2C00:  BRA    2C26
2C02:  BTFSS  F81.0
2C04:  BRA    2C26
....................             output_a(0b00000010); 
2C06:  MOVLW  02
2C08:  MOVWF  F89
....................             delay_ms(3); 
2C0A:  MOVLW  03
2C0C:  MOVWF  x8B
2C0E:  RCALL  25FC
....................             output_a(0b00000110); 
2C10:  MOVLW  06
2C12:  MOVWF  F89
....................             delay_ms(1); 
2C14:  MOVLW  01
2C16:  MOVWF  x8B
2C18:  RCALL  25FC
....................             a=0; 
2C1A:  CLRF   x87
....................             b=1; 
2C1C:  MOVLW  01
2C1E:  MOVWF  x88
....................             c=0; 
2C20:  CLRF   x89
....................             d=0; 
2C22:  CLRF   x8A
....................         } 
2C24:  BRA    2BE6
....................         while(!input(pin_b7) && !input(pin_b6) && !input(pin_b5) && !input(pin_b4) && !input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2C26:  BTFSC  F81.7
2C28:  BRA    2C66
2C2A:  BTFSC  F81.6
2C2C:  BRA    2C66
2C2E:  BTFSC  F81.5
2C30:  BRA    2C66
2C32:  BTFSC  F81.4
2C34:  BRA    2C66
2C36:  BTFSC  F81.3
2C38:  BRA    2C66
2C3A:  BTFSS  F81.2
2C3C:  BRA    2C66
2C3E:  BTFSS  F81.1
2C40:  BRA    2C66
2C42:  BTFSS  F81.0
2C44:  BRA    2C66
....................             output_a(0b00000010); 
2C46:  MOVLW  02
2C48:  MOVWF  F89
....................             delay_ms(3); 
2C4A:  MOVLW  03
2C4C:  MOVWF  x8B
2C4E:  RCALL  25FC
....................             output_a(0b00000110); 
2C50:  MOVLW  06
2C52:  MOVWF  F89
....................             delay_ms(1); 
2C54:  MOVLW  01
2C56:  MOVWF  x8B
2C58:  RCALL  25FC
....................             a=0; 
2C5A:  CLRF   x87
....................             b=1; 
2C5C:  MOVLW  01
2C5E:  MOVWF  x88
....................             c=0; 
2C60:  CLRF   x89
....................             d=0; 
2C62:  CLRF   x8A
....................         } 
2C64:  BRA    2C26
....................         while(input(pin_b7) && !input(pin_b6) && !input(pin_b5) && !input(pin_b4) && !input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2C66:  BTFSS  F81.7
2C68:  BRA    2CA6
2C6A:  BTFSC  F81.6
2C6C:  BRA    2CA6
2C6E:  BTFSC  F81.5
2C70:  BRA    2CA6
2C72:  BTFSC  F81.4
2C74:  BRA    2CA6
2C76:  BTFSC  F81.3
2C78:  BRA    2CA6
2C7A:  BTFSS  F81.2
2C7C:  BRA    2CA6
2C7E:  BTFSS  F81.1
2C80:  BRA    2CA6
2C82:  BTFSS  F81.0
2C84:  BRA    2CA6
....................             output_a(0b00000010); 
2C86:  MOVLW  02
2C88:  MOVWF  F89
....................             delay_ms(3); 
2C8A:  MOVLW  03
2C8C:  MOVWF  x8B
2C8E:  RCALL  25FC
....................             output_a(0b00000110); 
2C90:  MOVLW  06
2C92:  MOVWF  F89
....................             delay_ms(1); 
2C94:  MOVLW  01
2C96:  MOVWF  x8B
2C98:  RCALL  25FC
....................             a=0; 
2C9A:  CLRF   x87
....................             b=1; 
2C9C:  MOVLW  01
2C9E:  MOVWF  x88
....................             c=0; 
2CA0:  CLRF   x89
....................             d=0; 
2CA2:  CLRF   x8A
....................         } 
2CA4:  BRA    2C66
....................          while(!input(pin_b7) && !input(pin_b6) && !input(pin_b5) && !input(pin_b4) && !input(pin_b3) && !input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2CA6:  BTFSC  F81.7
2CA8:  BRA    2CE6
2CAA:  BTFSC  F81.6
2CAC:  BRA    2CE6
2CAE:  BTFSC  F81.5
2CB0:  BRA    2CE6
2CB2:  BTFSC  F81.4
2CB4:  BRA    2CE6
2CB6:  BTFSC  F81.3
2CB8:  BRA    2CE6
2CBA:  BTFSC  F81.2
2CBC:  BRA    2CE6
2CBE:  BTFSS  F81.1
2CC0:  BRA    2CE6
2CC2:  BTFSS  F81.0
2CC4:  BRA    2CE6
....................             output_a(0b00000010); 
2CC6:  MOVLW  02
2CC8:  MOVWF  F89
....................             delay_ms(4); 
2CCA:  MOVLW  04
2CCC:  MOVWF  x8B
2CCE:  RCALL  25FC
....................             output_a(0b00000110); 
2CD0:  MOVLW  06
2CD2:  MOVWF  F89
....................             delay_ms(1); 
2CD4:  MOVLW  01
2CD6:  MOVWF  x8B
2CD8:  RCALL  25FC
....................             a=0; 
2CDA:  CLRF   x87
....................             b=1; 
2CDC:  MOVLW  01
2CDE:  MOVWF  x88
....................             c=0; 
2CE0:  CLRF   x89
....................             d=0; 
2CE2:  CLRF   x8A
....................         } 
2CE4:  BRA    2CA6
....................         while(!input(pin_b7) && !input(pin_b6) && !input(pin_b5) && !input(pin_b4) && !input(pin_b3) && !input(pin_b2) && !input(pin_b1) && input(pin_b0)) 
....................         { 
2CE6:  BTFSC  F81.7
2CE8:  BRA    2D26
2CEA:  BTFSC  F81.6
2CEC:  BRA    2D26
2CEE:  BTFSC  F81.5
2CF0:  BRA    2D26
2CF2:  BTFSC  F81.4
2CF4:  BRA    2D26
2CF6:  BTFSC  F81.3
2CF8:  BRA    2D26
2CFA:  BTFSC  F81.2
2CFC:  BRA    2D26
2CFE:  BTFSC  F81.1
2D00:  BRA    2D26
2D02:  BTFSS  F81.0
2D04:  BRA    2D26
....................             output_a(0b00000010); 
2D06:  MOVLW  02
2D08:  MOVWF  F89
....................             delay_ms(4); 
2D0A:  MOVLW  04
2D0C:  MOVWF  x8B
2D0E:  RCALL  25FC
....................             output_a(0b00000110); 
2D10:  MOVLW  06
2D12:  MOVWF  F89
....................             delay_ms(1); 
2D14:  MOVLW  01
2D16:  MOVWF  x8B
2D18:  RCALL  25FC
....................             a=0; 
2D1A:  CLRF   x87
....................             b=1; 
2D1C:  MOVLW  01
2D1E:  MOVWF  x88
....................             c=0; 
2D20:  CLRF   x89
....................             d=0; 
2D22:  CLRF   x8A
....................         } 
2D24:  BRA    2CE6
....................         //90 derece dönüþler 
....................         while((a==1) && input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2D26:  DECFSZ x87,W
2D28:  BRA    2D98
2D2A:  BTFSS  F81.7
2D2C:  BRA    2D98
2D2E:  BTFSS  F81.6
2D30:  BRA    2D98
2D32:  BTFSS  F81.5
2D34:  BRA    2D98
2D36:  BTFSS  F81.4
2D38:  BRA    2D98
2D3A:  BTFSS  F81.3
2D3C:  BRA    2D98
2D3E:  BTFSS  F81.2
2D40:  BRA    2D98
2D42:  BTFSS  F81.1
2D44:  BRA    2D98
2D46:  BTFSS  F81.0
2D48:  BRA    2D98
....................             output_a(0b00001000); 
2D4A:  MOVLW  08
2D4C:  MOVWF  F89
....................             delay_ms(1); 
2D4E:  MOVLW  01
2D50:  MOVWF  x8B
2D52:  RCALL  25FC
....................             output_a(0b00001001); 
2D54:  MOVLW  09
2D56:  MOVWF  F89
....................             delay_ms(2); 
2D58:  MOVLW  02
2D5A:  MOVWF  x8B
2D5C:  RCALL  25FC
....................             while(input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && !input(pin_b2) || !input(pin_b1) || !input(pin_b0)) 
....................             { 
2D5E:  BTFSS  F81.7
2D60:  BRA    2D76
2D62:  BTFSS  F81.6
2D64:  BRA    2D76
2D66:  BTFSS  F81.5
2D68:  BRA    2D76
2D6A:  BTFSS  F81.4
2D6C:  BRA    2D76
2D6E:  BTFSS  F81.3
2D70:  BRA    2D76
2D72:  BTFSS  F81.2
2D74:  BRA    2D7E
2D76:  BTFSS  F81.1
2D78:  BRA    2D7E
2D7A:  BTFSC  F81.0
2D7C:  BRA    2D96
....................                   a=0; 
2D7E:  CLRF   x87
....................                   output_a(0b00001000); 
2D80:  MOVLW  08
2D82:  MOVWF  F89
....................                   delay_ms(2); 
2D84:  MOVLW  02
2D86:  MOVWF  x8B
2D88:  RCALL  25FC
....................                   output_a(0b00001001); 
2D8A:  MOVLW  09
2D8C:  MOVWF  F89
....................                   delay_ms(2); 
2D8E:  MOVLW  02
2D90:  MOVWF  x8B
2D92:  RCALL  25FC
....................             } 
2D94:  BRA    2D5E
....................         } 
2D96:  BRA    2D26
....................          
....................         while((b==1) && input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................         { 
2D98:  DECFSZ x88,W
2D9A:  BRA    2E0A
2D9C:  BTFSS  F81.7
2D9E:  BRA    2E0A
2DA0:  BTFSS  F81.6
2DA2:  BRA    2E0A
2DA4:  BTFSS  F81.5
2DA6:  BRA    2E0A
2DA8:  BTFSS  F81.4
2DAA:  BRA    2E0A
2DAC:  BTFSS  F81.3
2DAE:  BRA    2E0A
2DB0:  BTFSS  F81.2
2DB2:  BRA    2E0A
2DB4:  BTFSS  F81.1
2DB6:  BRA    2E0A
2DB8:  BTFSS  F81.0
2DBA:  BRA    2E0A
....................             output_a(0b00000010); 
2DBC:  MOVLW  02
2DBE:  MOVWF  F89
....................             delay_ms(1); 
2DC0:  MOVLW  01
2DC2:  MOVWF  x8B
2DC4:  RCALL  25FC
....................             output_a(0b00000110); 
2DC6:  MOVLW  06
2DC8:  MOVWF  F89
....................             delay_ms(2); 
2DCA:  MOVLW  02
2DCC:  MOVWF  x8B
2DCE:  RCALL  25FC
....................             while(!input(pin_b7) || !input(pin_b6) || !input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................             { 
2DD0:  BTFSS  F81.7
2DD2:  BRA    2DF0
2DD4:  BTFSS  F81.6
2DD6:  BRA    2DF0
2DD8:  BTFSC  F81.5
2DDA:  BRA    2E08
2DDC:  BTFSS  F81.4
2DDE:  BRA    2E08
2DE0:  BTFSS  F81.3
2DE2:  BRA    2E08
2DE4:  BTFSS  F81.2
2DE6:  BRA    2E08
2DE8:  BTFSS  F81.1
2DEA:  BRA    2E08
2DEC:  BTFSS  F81.0
2DEE:  BRA    2E08
....................                   b=0; 
2DF0:  CLRF   x88
....................                   output_a(0b00000010); 
2DF2:  MOVLW  02
2DF4:  MOVWF  F89
....................                   delay_ms(2); 
2DF6:  MOVWF  x8B
2DF8:  RCALL  25FC
....................                   output_a(0b00000110); 
2DFA:  MOVLW  06
2DFC:  MOVWF  F89
....................                   delay_ms(2); 
2DFE:  MOVLW  02
2E00:  MOVWF  x8B
2E02:  CALL   25FC
....................             }             
2E06:  BRA    2DD0
....................         } 
2E08:  BRA    2D98
....................         //Kesik Çizgiler 
....................          while((c==1) && input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................          { 
2E0A:  DECFSZ x89,W
2E0C:  BRA    2F12
2E0E:  BTFSS  F81.7
2E10:  BRA    2F12
2E12:  BTFSS  F81.6
2E14:  BRA    2F12
2E16:  BTFSS  F81.5
2E18:  BRA    2F12
2E1A:  BTFSS  F81.4
2E1C:  BRA    2F12
2E1E:  BTFSS  F81.3
2E20:  BRA    2F12
2E22:  BTFSS  F81.2
2E24:  BRA    2F12
2E26:  BTFSS  F81.1
2E28:  BRA    2F12
2E2A:  BTFSS  F81.0
2E2C:  BRA    2F12
....................             output_a(0b00001010); 
2E2E:  MOVLW  0A
2E30:  MOVWF  F89
....................              
....................                   while(input(pin_b7) && input(pin_b6) && input(pin_b5) && !input(pin_b4) && !input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................                   { 
2E32:  BTFSS  F81.7
2E34:  BRA    2E58
2E36:  BTFSS  F81.6
2E38:  BRA    2E58
2E3A:  BTFSS  F81.5
2E3C:  BRA    2E58
2E3E:  BTFSC  F81.4
2E40:  BRA    2E58
2E42:  BTFSC  F81.3
2E44:  BRA    2E58
2E46:  BTFSS  F81.2
2E48:  BRA    2E58
2E4A:  BTFSS  F81.1
2E4C:  BRA    2E58
2E4E:  BTFSS  F81.0
2E50:  BRA    2E58
....................                      output_a(0b00001010); 
2E52:  MOVLW  0A
2E54:  MOVWF  F89
....................                   } 
2E56:  BRA    2E32
....................                   while(input(pin_b7) && input(pin_b6) && input(pin_b5) && !input(pin_b4) && !input(pin_b3) && !input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................                   { 
2E58:  BTFSS  F81.7
2E5A:  BRA    2E7E
2E5C:  BTFSS  F81.6
2E5E:  BRA    2E7E
2E60:  BTFSS  F81.5
2E62:  BRA    2E7E
2E64:  BTFSC  F81.4
2E66:  BRA    2E7E
2E68:  BTFSC  F81.3
2E6A:  BRA    2E7E
2E6C:  BTFSC  F81.2
2E6E:  BRA    2E7E
2E70:  BTFSS  F81.1
2E72:  BRA    2E7E
2E74:  BTFSS  F81.0
2E76:  BRA    2E7E
....................                      output_a(0b00001010); 
2E78:  MOVLW  0A
2E7A:  MOVWF  F89
....................                   } 
2E7C:  BRA    2E58
....................                   while(input(pin_b7) && input(pin_b6) && !input(pin_b5) && !input(pin_b4) && !input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0)) 
....................                   { 
2E7E:  BTFSS  F81.7
2E80:  BRA    2EA4
2E82:  BTFSS  F81.6
2E84:  BRA    2EA4
2E86:  BTFSC  F81.5
2E88:  BRA    2EA4
2E8A:  BTFSC  F81.4
2E8C:  BRA    2EA4
2E8E:  BTFSC  F81.3
2E90:  BRA    2EA4
2E92:  BTFSS  F81.2
2E94:  BRA    2EA4
2E96:  BTFSS  F81.1
2E98:  BRA    2EA4
2E9A:  BTFSS  F81.0
2E9C:  BRA    2EA4
....................                      output_a(0b00001010); 
2E9E:  MOVLW  0A
2EA0:  MOVWF  F89
....................                   } 
2EA2:  BRA    2E7E
....................                   while(input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && !input(pin_b3) && !input(pin_b2) && input(pin_b0)) 
....................                   { 
2EA4:  BTFSS  F81.7
2EA6:  BRA    2EDA
2EA8:  BTFSS  F81.6
2EAA:  BRA    2EDA
2EAC:  BTFSS  F81.5
2EAE:  BRA    2EDA
2EB0:  BTFSS  F81.4
2EB2:  BRA    2EDA
2EB4:  BTFSC  F81.3
2EB6:  BRA    2EDA
2EB8:  BTFSC  F81.2
2EBA:  BRA    2EDA
2EBC:  BTFSS  F81.0
2EBE:  BRA    2EDA
....................                      output_a(0b00001000); 
2EC0:  MOVLW  08
2EC2:  MOVWF  F89
....................                      delay_ms(1); 
2EC4:  MOVLW  01
2EC6:  MOVWF  x8B
2EC8:  CALL   25FC
....................                      output_a(0b00001010); 
2ECC:  MOVLW  0A
2ECE:  MOVWF  F89
....................                      delay_ms(3); 
2ED0:  MOVLW  03
2ED2:  MOVWF  x8B
2ED4:  CALL   25FC
....................                   } 
2ED8:  BRA    2EA4
....................                   while(input(pin_b7) && input(pin_b6) && !input(pin_b5) && !input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b0)) 
....................                   { 
2EDA:  BTFSS  F81.7
2EDC:  BRA    2F10
2EDE:  BTFSS  F81.6
2EE0:  BRA    2F10
2EE2:  BTFSC  F81.5
2EE4:  BRA    2F10
2EE6:  BTFSC  F81.4
2EE8:  BRA    2F10
2EEA:  BTFSS  F81.3
2EEC:  BRA    2F10
2EEE:  BTFSS  F81.2
2EF0:  BRA    2F10
2EF2:  BTFSS  F81.0
2EF4:  BRA    2F10
....................                      output_a(0b00000010); 
2EF6:  MOVLW  02
2EF8:  MOVWF  F89
....................                      delay_ms(1); 
2EFA:  MOVLW  01
2EFC:  MOVWF  x8B
2EFE:  CALL   25FC
....................                      output_a(0b00001010); 
2F02:  MOVLW  0A
2F04:  MOVWF  F89
....................                      delay_ms(3); 
2F06:  MOVLW  03
2F08:  MOVWF  x8B
2F0A:  CALL   25FC
....................                   } 
2F0E:  BRA    2EDA
....................          } 
2F10:  BRA    2E0A
....................          //Cisim 
....................        while (d==1 && input(pin_b7) && input(pin_b6) && input(pin_b5) && input(pin_b4) && input(pin_b3) && input(pin_b2) && input(pin_b1) && input(pin_b0) ) 
....................        { 
2F12:  DECFSZ x8A,W
2F14:  BRA    2FB0
2F16:  BTFSS  F81.7
2F18:  BRA    2FB0
2F1A:  BTFSS  F81.6
2F1C:  BRA    2FB0
2F1E:  BTFSS  F81.5
2F20:  BRA    2FB0
2F22:  BTFSS  F81.4
2F24:  BRA    2FB0
2F26:  BTFSS  F81.3
2F28:  BRA    2FB0
2F2A:  BTFSS  F81.2
2F2C:  BRA    2FB0
2F2E:  BTFSS  F81.1
2F30:  BRA    2FB0
2F32:  BTFSS  F81.0
2F34:  BRA    2FB0
....................          output_a(0b00001010); 
2F36:  MOVLW  0A
2F38:  MOVWF  F89
....................          delay_ms(2); 
2F3A:  MOVLW  02
2F3C:  MOVWF  x8B
2F3E:  CALL   25FC
....................          output_a(0b00001000); 
2F42:  MOVLW  08
2F44:  MOVWF  F89
....................          delay_ms(4); 
2F46:  MOVLW  04
2F48:  MOVWF  x8B
2F4A:  CALL   25FC
....................             while(!input(pin_b3) || !input(pin_b2) || !input(pin_b1) || !input(pin_b0)) 
....................             { 
2F4E:  BTFSS  F81.3
2F50:  BRA    2F5E
2F52:  BTFSS  F81.2
2F54:  BRA    2F5E
2F56:  BTFSS  F81.1
2F58:  BRA    2F5E
2F5A:  BTFSC  F81.0
2F5C:  BRA    2F7E
....................                output_a(0b00001000); 
2F5E:  MOVLW  08
2F60:  MOVWF  F89
....................                delay_ms(3); 
2F62:  MOVLW  03
2F64:  MOVWF  x8B
2F66:  CALL   25FC
....................                output_a(0b00001010); 
2F6A:  MOVLW  0A
2F6C:  MOVWF  F89
....................                delay_ms(1); 
2F6E:  MOVLW  01
2F70:  MOVWF  x8B
2F72:  CALL   25FC
....................                a=1; 
2F76:  MOVLW  01
2F78:  MOVWF  x87
....................                d=0; 
2F7A:  CLRF   x8A
....................             } 
2F7C:  BRA    2F4E
....................             while(!input(pin_b7) || !input(pin_b6) || !input(pin_b5) || !input(pin_b4)) 
....................             { 
2F7E:  BTFSS  F81.7
2F80:  BRA    2F8E
2F82:  BTFSS  F81.6
2F84:  BRA    2F8E
2F86:  BTFSS  F81.5
2F88:  BRA    2F8E
2F8A:  BTFSC  F81.4
2F8C:  BRA    2FAE
....................                output_a(0b00000010); 
2F8E:  MOVLW  02
2F90:  MOVWF  F89
....................                delay_ms(3); 
2F92:  MOVLW  03
2F94:  MOVWF  x8B
2F96:  CALL   25FC
....................                output_a(0b00001010); 
2F9A:  MOVLW  0A
2F9C:  MOVWF  F89
....................                delay_ms(1); 
2F9E:  MOVLW  01
2FA0:  MOVWF  x8B
2FA2:  CALL   25FC
....................                b=1; 
2FA6:  MOVLW  01
2FA8:  MOVWF  x88
....................                d=0; 
2FAA:  CLRF   x8A
....................             } 
2FAC:  BRA    2F7E
....................        } 
2FAE:  BRA    2F12
.................... }   // while 1 
2FB0:  GOTO   26BE
.................... }// void main 
....................  
....................  
2FB4:  SLEEP 

Configuration Fuses:
   Word  1: CC24   IESO FCMEN HS PLL5 CPUDIV1 USBDIV
   Word  2: 0E3F   BROWNOUT WDT128 NOWDT BORV20 NOPUT VREGEN
   Word  3: 8300   PBADEN CCP2C1 MCLR NOLPT1OSC RESERVED
   Word  4: 0085   STVREN NODEBUG LVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
